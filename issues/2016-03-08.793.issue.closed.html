<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
    
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
      <link rel="shortcut icon" href="../img/favicon.ico" />
    <meta property="og:title" content="Relax-and-Recover (ReaR) User Guide Documentation"/>
    <meta property="og:description" content="This is an umbrella documentation project for all Relax-and-Recover (ReaR) kind of documentation ans starting with a good User Guide."/>
    <meta property="og:locale" content="en_US"/>
    <meta property="og:url" content="https://relax-and-recover.org/rear-user-guide/"/>
    <meta property="og:type" content="website"/>
    <meta property="og:image" content="https://relax-and-recover.org/rear-user-guide/img/rear_logo_50.png"/>
    <meta property="og:image:width" content="50"/>
    <meta property="og:image:height" content="50"/>
    
    <title>#793 Issue closed: partprobe fails - Relax-and-Recover (ReaR) User Guide Documentation</title>
    <link rel="stylesheet" href="../css/theme.css" />
    <link rel="stylesheet" href="../css/theme_extra.css" />
        <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/styles/github.min.css" />
        <link href="../css/rear.css" rel="stylesheet" />
    
      <script>
        // Current page data
        var mkdocs_page_name = "#793 Issue closed: partprobe fails";
        var mkdocs_page_input_path = "issues/2016-03-08.793.issue.closed.md";
        var mkdocs_page_url = null;
      </script>
    
    <!--[if lt IE 9]>
      <script src="../js/html5shiv.min.js"></script>
    <![endif]-->
      <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/highlight.min.js"></script>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/languages/yaml.min.js"></script>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/languages/rust.min.js"></script>
      <script>hljs.highlightAll();</script> 
      <script>
        (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
        (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
        m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
        })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

        ga('create', "366986045", "auto");
        ga('send', 'pageview');
      </script>
    
</head>

<body class="wy-body-for-nav" role="document">

  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side stickynav">
    <div class="wy-side-scroll">
      <div class="wy-side-nav-search">
          <a href="../index.html" class="icon icon-home"> Relax-and-Recover (ReaR) User Guide Documentation
        </a><div role="search">
  <form id ="rtd-search-form" class="wy-form" action="../search.html" method="get">
      <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" title="Type search term here" />
  </form>
</div>
      </div>

      <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <ul>
                <li class="toctree-l1"><a class="reference internal" href="../index.html">Relax-and-Recover (ReaR) User Guide Documentation</a>
                </li>
              </ul>
              <p class="caption"><span class="caption-text">WELCOME</span></p>
              <ul>
                  <li class="toctree-l1"><a class="reference internal" href="../welcome/index.html">Get started!</a>
                  </li>
              </ul>
              <p class="caption"><span class="caption-text">BASICS</span></p>
              <ul>
                  <li class="toctree-l1"><a class="reference internal" href="../basics/introduction.html">Introduction</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../basics/history.html">Bit of History</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../basics/getting-started.html">Getting started with ReaR</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../basics/configuration.html">Basic configuration</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../basics/backup_netfs.html">Example of BACKUP=NETFS</a>
                  </li>
              </ul>
              <p class="caption"><span class="caption-text">SCENARIOS</span></p>
              <ul>
                  <li class="toctree-l1"><a class="reference internal" href="../scenarios/index.html">Scenarios Overview</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../scenarios/netfs_nas.html">Internal Backup with tar to NFS server</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../scenarios/netfs_rsync.html">Internal Backup with rsync to NFS server</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../scenarios/rbme.html">External Backup using RBME</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../scenarios/restic.html">External Backup using restic</a>
                  </li>
              </ul>
              <p class="caption"><span class="caption-text">DEVELOPMENT</span></p>
              <ul>
                  <li class="toctree-l1"><a class="reference internal" href="../development/github-pr.html">Make a pull request with GitHub</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../development/squash-git-log-commments.html">How to squash git log comments into one line</a>
                  </li>
              </ul>
              <p class="caption"><span class="caption-text">RELEASE NOTES</span></p>
              <ul>
                  <li class="toctree-l1"><a class="reference internal" href="../releasenotes/index.html">Release Notes</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../releasenotes/rear29.html">Release Notes ReaR 2.9</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../releasenotes/rear28.html">Release Notes ReaR 2.8</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../releasenotes/rear27.html">Release Notes ReaR 2.7</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../releasenotes/rear26.html">Release Notes ReaR 2.6</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../releasenotes/knownproblems.html">Known Problems and Workarounds</a>
                  </li>
              </ul>
              <p class="caption"><span class="caption-text">ISSUES</span></p>
              <ul>
                  <li class="toctree-l1"><a class="reference internal" href="index.html">Issues History</a>
                  </li>
              </ul>
              <p class="caption"><span class="caption-text">LEGAL</span></p>
              <ul>
                  <li class="toctree-l1"><a class="reference internal" href="../legal/contributing/index.html">Contributing</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../legal/license/index.html">License</a>
                  </li>
              </ul>
      </div>
    </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">
      <nav class="wy-nav-top" role="navigation" aria-label="Mobile navigation menu">
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">Relax-and-Recover (ReaR) User Guide Documentation</a>
        
      </nav>
      <div class="wy-nav-content">
        <div class="rst-content"><div role="navigation" aria-label="breadcrumbs navigation">
  <ul class="wy-breadcrumbs">
    <li><a href="../index.html" class="icon icon-home" aria-label="Docs"></a></li>
      <li class="breadcrumb-item active">#793 Issue closed: partprobe fails</li>
    <li class="wy-breadcrumbs-aside">
    </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
            <div class="section" itemprop="articleBody">
              
                <h1 id="793_issue_closed_partprobe_fails"><a href="https://github.com/rear/rear/issues/793">#793 Issue</a> <code>closed</code>: partprobe fails<a class="headerlink" href="#793_issue_closed_partprobe_fails" title="Permanent link">&para;</a></h1>
<p><strong>Labels</strong>: <code>bug</code>, <code>cleanup</code>, <code>support / question</code>,
<code>fixed / solved / done</code></p>
<h4 id="thefrenchone_opened_issue_at_2016-03-08_1827"><img src="https://avatars.githubusercontent.com/u/17705716?v=4" width="50"><a href="https://github.com/thefrenchone">thefrenchone</a> opened issue at <a href="https://github.com/rear/rear/issues/793">2016-03-08 18:27</a>:<a class="headerlink" href="#thefrenchone_opened_issue_at_2016-03-08_1827" title="Permanent link">&para;</a></h4>
<ul>
<li>rear version : 1.17.2 and recent Git</li>
<li>OS version : RHEL 7</li>
<li>rear configuration files: N/A</li>
</ul>
<p>udevadm settle doesn't appear to function correctly in RHEL 7. During
the disklayout stage of recovery partprobe -s /dev/sda fails 100% of the
time with resource is busy.</p>
<pre><code>Error: Error informing the kernel about modifications
to partition /dev/sda1 - Device or resouce busy.
This means linux won't know about any changes
you have made to the /dev/sda1 until you reboot - so
you shuldn't mount it or use it in any way before rebooting.
</code></pre>
<p>There are a a few workaround I have tried but most of them don't work
100% of the time. Sometimes including a sleep before partprobe works and
sometimes sleeping for a minute doesn't work. The only reliable
workaround I've found is to just call partprobe multiple times:</p>
<p>from:
/usr/share/rear/layout/prepate/GNU/Linux/10_include_partition_code.sh<br />
echo "partprobe -s $device &gt;&amp;2 || true"<br />
echo "partprobe -s $device &gt;&amp;2 || true""<br />
echo "partprobe -s $device &gt;&amp;2"</p>
<p>The "|| true" is to bypass the error checking.</p>
<p>Is there a better workaround planned? The main issue appears to be
udevadm settle not doing what it's supposed to. I have noticed issue
#791 points out issues with udevadm settle when partitioning which I
have also seen on a regular basis.</p>
<h4 id="jsmeix_commented_at_2016-03-09_0950"><img src="https://avatars.githubusercontent.com/u/1788608?u=925fc54e2ce01551392622446ece427f51e2f0ce&v=4" width="50"><a href="https://github.com/jsmeix">jsmeix</a> commented at <a href="https://github.com/rear/rear/issues/793#issuecomment-194215092">2016-03-09 09:50</a>:<a class="headerlink" href="#jsmeix_commented_at_2016-03-09_0950" title="Permanent link">&para;</a></h4>
<p>I think hammering on the poor kernel/udev/systemd/whatever<br />
with consecutive "partprobe" calls is not the very best thing.</p>
<p>But following the basic idea from
<a href="https://github.com/rear/rear/issues/791">https://github.com/rear/rear/issues/791</a></p>
<pre>
The right way is to wait for the actual "thingy" that is needed by the subsequent commands.
</pre>

<p>the following could be the right way in 10_include_partition_code.sh</p>
<pre>
    # Ensure we have the new partitioning on the device
    # by waiting for the actual "thingy" that is needed afterwards
    # (cf. https://github.com/rear/rear/issues/793)
    # which means we wait for a successful run of "partprobe"
    # to ensure the new partitioning can be used afterwards.
    # If there was no successful run of "partprobe"
    # within 120 seconds we give up with an error:
    (
    echo "for countdown in \$( seq 120 -1 0 ) ; do"
    echo "    test '0' = \$countdown && Error 'partprobe $device failed' "
    echo "    partprobe -s $device >&2 && break || true"
    echo "    LogPrint \"waiting for 'partprobe $device' (\$countdown)\""
    echo "    sleep 1"
    echo "done"
    ) >> "$LAYOUT_CODE"
</pre>

<p>Please test if it works reilably this way.</p>
<p>Because you mentioned<br />
"sometimes sleeping for a minute doesn't work"<br />
I use 120 seconds as maximum retry time.<br />
Perhaps you need even more.</p>
<h4 id="thefrenchone_commented_at_2016-03-09_1941"><img src="https://avatars.githubusercontent.com/u/17705716?v=4" width="50"><a href="https://github.com/thefrenchone">thefrenchone</a> commented at <a href="https://github.com/rear/rear/issues/793#issuecomment-194472562">2016-03-09 19:41</a>:<a class="headerlink" href="#thefrenchone_commented_at_2016-03-09_1941" title="Permanent link">&para;</a></h4>
<p>Your code worked for me. The countdown is a lot cleaner than what I had.</p>
<p>To clarify what I mean with sleep not working: it appears sleeping alone
isn't enough for udev to get it's act together. Sometimes a sleep 1
works. Usually a sleep 10 works. Occasionally udev just needs to be
kicked before it'll ever work. So sleep was never a reliable method for
some reason.</p>
<p>One alternative that also worked reliably was using vgchange to put the
root lvm group down then up before the partprobe. This depended on the
system using lvm but lvm appears to just wait until the device wasn't
busy instead of failing which was what I wanted.</p>
<p>The 120 second timeout may end up being far more than 120 seconds
because partprobe takes time to run. Plus time was never the actual
issue, it's more of udev needing a kick before partprobe is called. So a
final fix may not need sleep, although it's probably not a bad idea.</p>
<h4 id="jsmeix_commented_at_2016-03-10_0931"><img src="https://avatars.githubusercontent.com/u/1788608?u=925fc54e2ce01551392622446ece427f51e2f0ce&v=4" width="50"><a href="https://github.com/jsmeix">jsmeix</a> commented at <a href="https://github.com/rear/rear/issues/793#issuecomment-194753486">2016-03-10 09:31</a>:<a class="headerlink" href="#jsmeix_commented_at_2016-03-10_0931" title="Permanent link">&para;</a></h4>
<p>Regarding "udev just needs to be kicked":</p>
<p>As far as I was told "kicking udev" does not make sense.</p>
<p>Reason:</p>
<p>Again the crucial point is that the whole suff works based on events.</p>
<p>When "nothing happens" in udev it means there are no events.</p>
<p>When there are no events it does not change anything to "kick udev"
because udev will do nothing when there are no events.</p>
<p>Again the right way is the same idea as in
<a href="https://github.com/rear/rear/issues/791">https://github.com/rear/rear/issues/791</a>
which is here</p>
<pre>
"kick" the actual "thingy" that generates events for udev
</pre>

<p>The actual "thingy" that generates events for udev is the kernel.</p>
<p>When a partitioning tool has written whatever data on a harddisk<br />
that is meant to be used by the kernel as partitioning information,<br />
then the kernel does not "magically" know that those blocks<br />
which were written right now are partitioning data. The kernel<br />
blindly writes the blocks onto the harddisk. Afterwards the kernel<br />
must be explicitly told to read the new partitioning information<br />
from the harddisk. Traditionally this was done by calling "partprobe"<br />
after using a partitioning tool and that is the reason why there is<br />
that "partprobe" call at the end of 10_include_partition_code.sh</p>
<p>But I was told that nowadays partitioning tools have been enhanced<br />
that when finishing they do automatically what "partprobe" does<br />
which means nowadays the explicit "partprobe" call should be<br />
unnecessary.</p>
<p>Actually nowadays the explicit "partprobe" call could even lead<br />
to some kind of confusion or race conditioned failures as follows:</p>
<p>When a nowadays partitioning tool does automatically what<br />
"partprobe" does and additionally an explicit "partprobe" call<br />
is done then the "partprobe" call could fail because the harddisk<br />
device is blocked/busy because the kernel is still busy with the<br />
perceding task that was triggered automatically by the partitioning<br />
tool. Probably this describes the reason why in your case<br />
"partprobe -s /dev/sda fails 100% of the time with resource is busy".</p>
<p>Therefore when a nowadays partitioning tool (parted) is used,<br />
the explicit "partprobe" call should be skipped.</p>
<p>The problem in rear is:</p>
<p>How to autodetect whether or not the particular parted program<br />
that is installed on a particular user's system does automatically<br />
what partprobe does so that the explicit partprobe call can be<br />
skipped?</p>
<p>I am totally against testing opearting system verdor and version<br />
because that is totally against the very basic idea behind
<a href="https://github.com/rear/rear/issues/791">https://github.com/rear/rear/issues/791</a>
which is here:</p>
<pre>
The right way is to test for the actual "thingy".
</pre>

<p>Because I cannot imagine how I could test a particular parted program<br />
whether or not it does automatically what partprobe does,<br />
I think the best idea is a backward compatible and fail safe approach<br />
as follows:</p>
<p>After the last parted call do a hardcoded sleep of 1 second<br />
so that the kernel/udev get a bit of time to process possibly<br />
automated triggers of parted (i.e. for nowadays parted),<br />
afterwards call partprobe explicitly, and wait 10 seconds if it
failed,<br />
finally call partprobe again explicitly and ignore if that also failed:</p>
<pre>
    # Try to ensure the kernel uses the new partitioning
    # see https://github.com/rear/rear/issues/793
    # First do a hardcoded sleep of 1 second so that
    # the kernel and udev get a bit of time to process
    # automated "read partition table changes" triggers
    # of nowadays parted.
    # Then to be backward compatible with traditional parted
    # call partprobe explicitly to trigger the kernel
    # to "read partition table changes" and if that fails
    # wait 10 seconds before a first retry and if that fails
    # wait 60 seconds before a final retry and if that fails
    # ignore that failure and proceed "bona fide" because
    # nowadays it should "just work" regardless of partprobe.
    (
    echo "sleep 1"
    echo "if ! partprobe -s $device >&2 ; then"
    echo "    LogPrint 'retrying partprobe $device after 10 seconds' "
    echo "    sleep 10"
    echo "    if ! partprobe -s $device >&2 ; then"
    echo "        LogPrint 'retrying partprobe $device after 1 minute' "
    echo "        sleep 60"
    echo "        if ! partprobe -s $device >&2 ; then"
    echo "            LogPrint 'partprobe $device failed, proceeding bona fide' "
    echo "        fi"
    echo "    fi"
    echo "fi"
    ) >> "$LAYOUT_CODE"
</pre>

<h4 id="jsmeix_commented_at_2016-03-10_0940"><img src="https://avatars.githubusercontent.com/u/1788608?u=925fc54e2ce01551392622446ece427f51e2f0ce&v=4" width="50"><a href="https://github.com/jsmeix">jsmeix</a> commented at <a href="https://github.com/rear/rear/issues/793#issuecomment-194757052">2016-03-10 09:40</a>:<a class="headerlink" href="#jsmeix_commented_at_2016-03-10_0940" title="Permanent link">&para;</a></h4>
<p>FYI regarding the "I was told" in my comment above:</p>
<p>I am not at all a kernel or udev or partitioning tools expert.</p>
<p>I only report here what "I was told".</p>
<h4 id="gdha_commented_at_2016-03-10_1528"><img src="https://avatars.githubusercontent.com/u/888633?u=cdaeb31efcc0048d3619651aa18dd4b76e636b21&v=4" width="50"><a href="https://github.com/gdha">gdha</a> commented at <a href="https://github.com/rear/rear/issues/793#issuecomment-194904929">2016-03-10 15:28</a>:<a class="headerlink" href="#gdha_commented_at_2016-03-10_1528" title="Permanent link">&para;</a></h4>
<p>@jsmeix is this a bug? And, do you want to commit before we do a
release?</p>
<h4 id="jsmeix_commented_at_2016-03-10_1541"><img src="https://avatars.githubusercontent.com/u/1788608?u=925fc54e2ce01551392622446ece427f51e2f0ce&v=4" width="50"><a href="https://github.com/jsmeix">jsmeix</a> commented at <a href="https://github.com/rear/rear/issues/793#issuecomment-194911551">2016-03-10 15:41</a>:<a class="headerlink" href="#jsmeix_commented_at_2016-03-10_1541" title="Permanent link">&para;</a></h4>
<p>@gdha good question - I don't know.</p>
<p>For my tests all had "just worked" on my SLE12 test systems but as I
explained in
<a href="https://github.com/rear/rear/issues/791">https://github.com/rear/rear/issues/791</a>
I think the whole udev related waiting/triggering code in rear should be
reviewed/reconsidered but I think this should happen without any time
pressure (i.e. after the 1.18 release), cf. my "Milestone" setting in
<a href="https://github.com/rear/rear/issues/791">https://github.com/rear/rear/issues/791</a></p>
<p>On the other hand if udev-related things often fail in newer/newest Red
Hat versions the issue might become a blocker bug for the 1.18 release -
and then I could of course do a pull request.</p>
<h4 id="jsmeix_commented_at_2016-03-11_1455"><img src="https://avatars.githubusercontent.com/u/1788608?u=925fc54e2ce01551392622446ece427f51e2f0ce&v=4" width="50"><a href="https://github.com/jsmeix">jsmeix</a> commented at <a href="https://github.com/rear/rear/issues/793#issuecomment-195399804">2016-03-11 14:55</a>:<a class="headerlink" href="#jsmeix_commented_at_2016-03-11_1455" title="Permanent link">&para;</a></h4>
<p>@gdha have a look at my
<a href="https://github.com/rear/rear/pull/797">https://github.com/rear/rear/pull/797</a></p>
<p>If you like it please merge it.</p>
<p>At least from my point of view it is backward compatible<br />
so that there should be no regressions if you merge it.</p>
<p>@thefrenchone please test my
<a href="https://github.com/rear/rear/pull/797">https://github.com/rear/rear/pull/797</a>
if that also makes it work for your case.</p>
<h4 id="thefrenchone_commented_at_2016-03-11_1710"><img src="https://avatars.githubusercontent.com/u/17705716?v=4" width="50"><a href="https://github.com/thefrenchone">thefrenchone</a> commented at <a href="https://github.com/rear/rear/issues/793#issuecomment-195458756">2016-03-11 17:10</a>:<a class="headerlink" href="#thefrenchone_commented_at_2016-03-11_1710" title="Permanent link">&para;</a></h4>
<p>@jsmeix I've tested some variations of your code</p>
<pre><code>    echo "for countdown in \$( seq 120 -1 0 ) ; do"
    echo "    test '0' = \$countdown &amp;&amp; Error 'partprobe $device failed' "
    echo "    partprobe -s $device &gt;&amp;2 &amp;&amp; break || true"
    echo "    LogPrint \"waiting for 'partprobe $device' (\$countdown)\""
    echo "    sleep 1"
    echo "done"
    ) &gt;&gt; "$LAYOUT_CODE"
</code></pre>
<p>There are a few modification I ended up making for my testing. At most
this is 10 attempts of partprobe with sleep getting longer on each
attempt.</p>
<pre><code>    echo "for countdown in \$( seq 0 10 ) ; do"
    echo "    test '10' = \$countdown &amp;&amp; Error 'partprobe $device failed' "
    echo "    partprobe -s $device &gt;&amp;2 &amp;&amp; break || true"
    echo "    LogPrint \"waiting for 'partprobe $device' (\$countdown)\""
    echo "    sleep \$countdown"
    echo "done"
    ) &gt;&gt; "$LAYOUT_CODE"
</code></pre>
<p>Testing this I found that partprobe always succeeded on the second
attempt.</p>
<p>Looking at your commit I don't see anything that will cause any issues.
For my use case I expect the first partprobe will always fail and the
second to always succeed. In my testing of your commit the second
partprobe always succeeded. Anything less that 'sleep 3' and the second
partprobe would fail. At least that's the case today.</p>
<p>The timing difference between the two methods shows how inconsistent
this problem is. Using the loop method I only have a 'sleep 0' between
the first and second partprobe. The if/else method required at least a
sleep 3 between the first and second partprobe.</p>
<p>For my uses I'm probably going to keep the countdown with more partprobe
attempts. Sleeping for 10 seconds before the second attempt is safe but
I prefer to make more attempts in that time frame.</p>
<p>Thank you @jsmeix for #797</p>
<h4 id="jsmeix_commented_at_2016-03-14_0821"><img src="https://avatars.githubusercontent.com/u/1788608?u=925fc54e2ce01551392622446ece427f51e2f0ce&v=4" width="50"><a href="https://github.com/jsmeix">jsmeix</a> commented at <a href="https://github.com/rear/rear/issues/793#issuecomment-196196448">2016-03-14 08:21</a>:<a class="headerlink" href="#jsmeix_commented_at_2016-03-14_0821" title="Permanent link">&para;</a></h4>
<p>@thefrenchone many thanks for your feedback!</p>
<h4 id="jsmeix_commented_at_2016-05-23_0859"><img src="https://avatars.githubusercontent.com/u/1788608?u=925fc54e2ce01551392622446ece427f51e2f0ce&v=4" width="50"><a href="https://github.com/jsmeix">jsmeix</a> commented at <a href="https://github.com/rear/rear/issues/793#issuecomment-220924497">2016-05-23 08:59</a>:<a class="headerlink" href="#jsmeix_commented_at_2016-05-23_0859" title="Permanent link">&para;</a></h4>
<p>The error message in the initial comment<br />
<a href="https://github.com/rear/rear/issues/793#issue-139355299">https://github.com/rear/rear/issues/793#issue-139355299</a><br />
matches exactly what is described here:<br />
<a href="https://github.com/cockpit-project/cockpit/issues/3177">https://github.com/cockpit-project/cockpit/issues/3177</a><br />
I guess this one describes the root cause.</p>
<h4 id="jsmeix_commented_at_2016-06-29_0915"><img src="https://avatars.githubusercontent.com/u/1788608?u=925fc54e2ce01551392622446ece427f51e2f0ce&v=4" width="50"><a href="https://github.com/jsmeix">jsmeix</a> commented at <a href="https://github.com/rear/rear/issues/793#issuecomment-229302267">2016-06-29 09:15</a>:<a class="headerlink" href="#jsmeix_commented_at_2016-06-29_0915" title="Permanent link">&para;</a></h4>
<p>Now it happened for the very first time to me,<br />
see
<a href="https://github.com/rear/rear/issues/897">https://github.com/rear/rear/issues/897</a></p>
<h4 id="jsmeix_commented_at_2016-06-29_0937"><img src="https://avatars.githubusercontent.com/u/1788608?u=925fc54e2ce01551392622446ece427f51e2f0ce&v=4" width="50"><a href="https://github.com/jsmeix">jsmeix</a> commented at <a href="https://github.com/rear/rear/issues/793#issuecomment-229307360">2016-06-29 09:37</a>:<a class="headerlink" href="#jsmeix_commented_at_2016-06-29_0937" title="Permanent link">&para;</a></h4>
<p>No
<a href="https://github.com/rear/rear/issues/897">https://github.com/rear/rear/issues/897</a>
is false alarm.</p>
<p>I wished I could really reproduce such a parted failure.</p>
<h4 id="pcahyna_commented_at_2017-10-13_1741"><img src="https://avatars.githubusercontent.com/u/26300485?u=9105d243bc9f7ade463a3e52e8dd13fa67837158&v=4" width="50"><a href="https://github.com/pcahyna">pcahyna</a> commented at <a href="https://github.com/rear/rear/issues/793#issuecomment-336520391">2017-10-13 17:41</a>:<a class="headerlink" href="#pcahyna_commented_at_2017-10-13_1741" title="Permanent link">&para;</a></h4>
<p>I think I might have a more elegant fix. Since udevd locks the device
using flock(), what about avoiding such races by</p>
<pre><code>diff --git a/usr/share/rear/conf/Linux-i386.conf b/usr/share/rear/conf/Linux-i386.conf
index b1a3002..7d1c364 100644
--- a/usr/share/rear/conf/Linux-i386.conf
+++ b/usr/share/rear/conf/Linux-i386.conf
@@ -8,6 +8,7 @@ PROGS=(
 "${PROGS[@]}"
 grub
 partprobe
+flock
 lilo
 fdisk
 cfdisk
diff --git a/usr/share/rear/layout/prepare/GNU/Linux/10_include_partition_code.sh b/usr/share/rear/layout/prepare/GNU/Linux/10_include_partition_code.sh
index 9dad6a0..b84354f 100644
--- a/usr/share/rear/layout/prepare/GNU/Linux/10_include_partition_code.sh
+++ b/usr/share/rear/layout/prepare/GNU/Linux/10_include_partition_code.sh
@@ -235,7 +235,7 @@ EOF
     # Ensure we have the new partitioning on the device.
     (
     echo "my_udevsettle"
-    echo "partprobe -s $device &gt;&amp;2"
+    echo "flock $device partprobe -s $device &gt;&amp;2"
     echo "my_udevsettle"
     ) &gt;&gt; "$LAYOUT_CODE"
 }
</code></pre>
<h4 id="jsmeix_commented_at_2017-10-16_1014"><img src="https://avatars.githubusercontent.com/u/1788608?u=925fc54e2ce01551392622446ece427f51e2f0ce&v=4" width="50"><a href="https://github.com/jsmeix">jsmeix</a> commented at <a href="https://github.com/rear/rear/issues/793#issuecomment-336843255">2017-10-16 10:14</a>:<a class="headerlink" href="#jsmeix_commented_at_2017-10-16_1014" title="Permanent link">&para;</a></h4>
<p>@pcahyna<br />
on first galnce I don't like to introduce one more tool "flock"<br />
to work around the fundamentally inappropriate way<br />
how that things are implemented in ReaR - at least<br />
as far as I understand how that actually works, cf.<br />
<a href="https://github.com/rear/rear/issues/791">https://github.com/rear/rear/issues/791</a></p>
<p>We would need to ensure udev works same<br />
for all (even relatively old) Linux distributions that are<br />
supported by ReaR and that for something where<br />
ReaR should not at all interfere with udev, cf.<br />
<a href="https://github.com/rear/rear/issues/791">https://github.com/rear/rear/issues/791</a></p>
<p>Something else might suddenly fail in whatever<br />
unexpected ways when ReaR locks devices.</p>
<p>I wonder if partprobe needs to use the device exclusively,<br />
why then partprobe itself does not lock the device<br />
but the caller of partprobe must do the locking?</p>
<p>Finally - as far as I know - partprobe seems to be<br />
only needed in older Linux distributions, cf.<br />
<a href="https://github.com/rear/rear/issues/791#issuecomment-195323149">https://github.com/rear/rear/issues/791#issuecomment-195323149</a></p>
<p>I think the whole "partitioning code" in ReaR would need<br />
to be overhauled to make it work in compliance with<br />
<a href="https://github.com/rear/rear/issues/791">https://github.com/rear/rear/issues/791</a></p>
<p>But - as always - I find no time to do such major work<br />
because - as always - this or that particular issue<br />
of this or that particular user gets in the way.</p>
<h4 id="pcahyna_commented_at_2017-10-16_1712"><img src="https://avatars.githubusercontent.com/u/26300485?u=9105d243bc9f7ade463a3e52e8dd13fa67837158&v=4" width="50"><a href="https://github.com/pcahyna">pcahyna</a> commented at <a href="https://github.com/rear/rear/issues/793#issuecomment-336956244">2017-10-16 17:12</a>:<a class="headerlink" href="#pcahyna_commented_at_2017-10-16_1712" title="Permanent link">&para;</a></h4>
<p>@jsmeix</p>
<blockquote>
<p>on first galnce I don't like to introduce one more tool "flock"</p>
</blockquote>
<p>Is it a problem? flock has been a part of the util-linux package for
many years (it was there already in the initial import to Git in 2006)
and util-linux is one of the most basic packages. ReaR most likely
depends on it in many other places.</p>
<blockquote>
<p>to work around the fundamentally inappropriate way how that things are
implemented in ReaR</p>
</blockquote>
<p>Any "appropriate way" to implement this will need some kind of
synchronization to prevent races (especially, as you say, with udev on
the relatively old Linux distributions) and so I don't see how using
"flock" is a workaround rather than a step towards the right solution.
Retrying in a loop (as done here and also in #1370 which is a very
similar kind of issue) is what I would call a workaround. Or do you have
a better suggestion how to do this synchronization? "udevadm settle"
does not seem to work reliably (I think you pointed out as well that it
is not the right solution).</p>
<blockquote>
<p>Something else might suddenly fail in whatever<br />
unexpected ways when ReaR locks devices.</p>
</blockquote>
<p>One can never exclude unexpected problems, but I believe the chance is
very slim. "Something else" would need to use locking as well to be
affected by locking in ReaR and in this case this "something else" must
be prepared to handle the case when the resource is locked because this
is why locking is used in the first place.</p>
<blockquote>
<p>I wonder if partprobe needs to use the device exclusively,<br />
why then partprobe itself does not lock the device<br />
but the caller of partprobe must do the locking?</p>
</blockquote>
<p>I don't know, most likely it is because the authors haven't thought
about interaction with udev. Anyway it is the case and we should handle
it somehow.</p>
<blockquote>
<p>Finally - as far as I know - partprobe seems to be<br />
only needed in older Linux distributions</p>
</blockquote>
<p>Indeed, parted nowadays does the same job as partprobe (it is the same
code base, so the code is literally identical) and therefore partprobe
is unneeded, but this means that parted may encounter exactly the same
problem as partprobe does, so IMO the problem merely shifts from one
place to another. (This means that parted invocation should be protected
by the same lock as partprobe's.)</p>
<h4 id="gozora_commented_at_2017-10-16_1805"><img src="https://avatars.githubusercontent.com/u/12116358?u=1c5ba9dcee5ca3082f03029a7fbe647efd30eb49&v=4" width="50"><a href="https://github.com/gozora">gozora</a> commented at <a href="https://github.com/rear/rear/issues/793#issuecomment-336975629">2017-10-16 18:05</a>:<a class="headerlink" href="#gozora_commented_at_2017-10-16_1805" title="Permanent link">&para;</a></h4>
<p>I don't have broad experience with flock(1), but as far as I remember
Linux does not have mandatory locking hence it make sense to use
flock(1) only with cooperating processes.<br />
Reading <a href="https://fossies.org/dox/parted-3.2/partprobe_8c_source.html">partprobe
source</a>, I
can't find any evidence that it cares about file locking, but I might be
wrong of course ;-).</p>
<p>V.</p>
<h4 id="pcahyna_commented_at_2017-10-16_1822"><img src="https://avatars.githubusercontent.com/u/26300485?u=9105d243bc9f7ade463a3e52e8dd13fa67837158&v=4" width="50"><a href="https://github.com/pcahyna">pcahyna</a> commented at <a href="https://github.com/rear/rear/issues/793#issuecomment-336982358">2017-10-16 18:22</a>:<a class="headerlink" href="#pcahyna_commented_at_2017-10-16_1822" title="Permanent link">&para;</a></h4>
<p>@gozora</p>
<blockquote>
<p>as far as I remember Linux does not have mandatory locking</p>
</blockquote>
<p>Indeed.</p>
<blockquote>
<p>hence it make sense to use flock(1) only with cooperating processes.</p>
</blockquote>
<p>flock(1) exists to be used with processes which do not use locking
themselves, as it is able to execute them with the lock taken, even if
they do not take the lock themselves.</p>
<p>(Maybe I don't understand what you mean by "cooperating processes".)</p>
<blockquote>
<p>Reading partprobe source, I can't find any evidence that it cares
about file locking, but I might be wrong of course ;-).</p>
</blockquote>
<p>Exactly. partprobe/parted won't lock the device node, that's why using
flock(1) is needed to take the lock on their behalf. (If we want to
synchronize with udev using a lock, of course.)</p>
<h4 id="gozora_commented_at_2017-10-16_1833"><img src="https://avatars.githubusercontent.com/u/12116358?u=1c5ba9dcee5ca3082f03029a7fbe647efd30eb49&v=4" width="50"><a href="https://github.com/gozora">gozora</a> commented at <a href="https://github.com/rear/rear/issues/793#issuecomment-336986862">2017-10-16 18:33</a>:<a class="headerlink" href="#gozora_commented_at_2017-10-16_1833" title="Permanent link">&para;</a></h4>
<p>Don't take me for an expert here, I'm only curious, but if you have
system without mandatory locking how can one ensure that locking of
whatever file will be followed?</p>
<p>I mean if you <code>flock $device</code> for <code>partprobe</code> I guess your intention is
to disallow any other process to access <code>$device</code>, but any other process
that wants to access $device is free to do so (e.g. <code>vi $device</code>).<br />
That is where cooperating processes comes in play. I'd expect that flock
have sense to use only with other <code>flock</code> call (e.g flock $device vi
$device) or with any application that cares about locks
(<code>fcntl (..., F_GETFL, 0)</code>).</p>
<p>V.</p>
<h4 id="pcahyna_commented_at_2017-10-16_1841"><img src="https://avatars.githubusercontent.com/u/26300485?u=9105d243bc9f7ade463a3e52e8dd13fa67837158&v=4" width="50"><a href="https://github.com/pcahyna">pcahyna</a> commented at <a href="https://github.com/rear/rear/issues/793#issuecomment-336989952">2017-10-16 18:41</a>:<a class="headerlink" href="#pcahyna_commented_at_2017-10-16_1841" title="Permanent link">&para;</a></h4>
<p>@gozora the intention is not to disallow any other process to access
$device (this is indeed impossible as you point out), but to disallow
only udev to do so (or rather wait for udev to be finished with the
device). And udev is a "cooperating process" in your sense (it uses
flock(2) to lock the device nodes). So the proposal is that ReaR (or
rather its subprocesses, more precisely) becomes a cooperating process
as well.</p>
<h4 id="pcahyna_commented_at_2017-10-16_1845"><img src="https://avatars.githubusercontent.com/u/26300485?u=9105d243bc9f7ade463a3e52e8dd13fa67837158&v=4" width="50"><a href="https://github.com/pcahyna">pcahyna</a> commented at <a href="https://github.com/rear/rear/issues/793#issuecomment-336991268">2017-10-16 18:45</a>:<a class="headerlink" href="#pcahyna_commented_at_2017-10-16_1845" title="Permanent link">&para;</a></h4>
<p>@gozora small nit: you should not use <code>fcntl(..., F_GETFL, 0)</code> but
<code>flock(...)</code> (flock(2)) to cooperate with flock(1), because flock(1)
calls flock(2) and the two locking mechanisms (fcntl(2) and flock(2))
are independent.</p>
<h4 id="gozora_commented_at_2017-10-16_1903"><img src="https://avatars.githubusercontent.com/u/12116358?u=1c5ba9dcee5ca3082f03029a7fbe647efd30eb49&v=4" width="50"><a href="https://github.com/gozora">gozora</a> commented at <a href="https://github.com/rear/rear/issues/793#issuecomment-336998152">2017-10-16 19:03</a>:<a class="headerlink" href="#gozora_commented_at_2017-10-16_1903" title="Permanent link">&para;</a></h4>
<p>@pcahyna thank you kind sir ;-)!<br />
If udev really know flock then all you've told make perfect sense to me
now!</p>
<p>Now the question remains how reliable/bulletproof this locking is.<br />
How it behaves if things go wrong?<br />
Can it be that that deadlocks occurs?<br />
It would not be much of a fun rebooting server because my DR solution
does not allow udev to operate with HW ;-)<br />
As fat as I remember current solution, maybe not so elegant, but is
pretty peaceful.</p>
<p>V.</p>
<h4 id="gdha_commented_at_2017-10-17_0803"><img src="https://avatars.githubusercontent.com/u/888633?u=cdaeb31efcc0048d3619651aa18dd4b76e636b21&v=4" width="50"><a href="https://github.com/gdha">gdha</a> commented at <a href="https://github.com/rear/rear/issues/793#issuecomment-337150869">2017-10-17 08:03</a>:<a class="headerlink" href="#gdha_commented_at_2017-10-17_0803" title="Permanent link">&para;</a></h4>
<p>I've been using the flock trick for many years in my scripts for
creating Business Copy pairs as our scheduler had the bad behaviour to
launch many similar processes at the same second. We will change the
scheduler software soon ;-)</p>
<h4 id="jsmeix_commented_at_2017-10-17_0939"><img src="https://avatars.githubusercontent.com/u/1788608?u=925fc54e2ce01551392622446ece427f51e2f0ce&v=4" width="50"><a href="https://github.com/jsmeix">jsmeix</a> commented at <a href="https://github.com/rear/rear/issues/793#issuecomment-337176658">2017-10-17 09:39</a>:<a class="headerlink" href="#jsmeix_commented_at_2017-10-17_0939" title="Permanent link">&para;</a></h4>
<p>@pcahyna<br />
many thanks for your detailed background explanation.<br />
It helps at least me a lot to understand your idea behind.</p>
<p>In particular your<br />
<a href="https://github.com/rear/rear/issues/793#issuecomment-336989952">https://github.com/rear/rear/issues/793#issuecomment-336989952</a><br />
to avoid races with udev while "we" (i.e. ReaR) are running parted<br />
looks very useful in particular because of your<br />
<a href="https://github.com/rear/rear/issues/793#issuecomment-336982358">https://github.com/rear/rear/issues/793#issuecomment-336982358</a><br />
that parted itself does not care about locking<br />
so that "we" (i.e. ReaR) must care.</p>
<p>@gozora<br />
regarding other processes that may also want to access the device:<br />
While "rear recover" runs there are not much other processes.<br />
In particular "rear recover" is the only user process.<br />
So we only need to care about possible system processes<br />
and - fortunately - udev is a "cooperating process" that<br />
is prepared when ReaR uses "flock(1)".</p>
<p>@pcahyna<br />
I wonder if the flock default "waiting indefinitely for the lock<br />
to become available" is right.<br />
I think after a reasonable timeout ReaR should report something<br />
to the user e.g. like</p>
<pre>
until flock --timeout=3 $device partprobe -s $device ; do
    echo "Retrying 'flock $device partprobe -s $device'"
    sleep 1
done
</pre>

<p>The 'sleep 1' is crucial to avoid a thight runnning loop<br />
that can happen e.g. when $device does not exist.<br />
The '--timeout=3' is the only supported way for old flock<br />
e.g. in SLES10 where "man flock" only shows those options:</p>
<pre>
SYNOPSIS
    flock [ --shared | --timeout=seconds ] lockfile command ..
</pre>

<p>and '--timeout=seconds' also works on SLES12.</p>
<h4 id="pcahyna_commented_at_2017-10-18_1634"><img src="https://avatars.githubusercontent.com/u/26300485?u=9105d243bc9f7ade463a3e52e8dd13fa67837158&v=4" width="50"><a href="https://github.com/pcahyna">pcahyna</a> commented at <a href="https://github.com/rear/rear/issues/793#issuecomment-337650650">2017-10-18 16:34</a>:<a class="headerlink" href="#pcahyna_commented_at_2017-10-18_1634" title="Permanent link">&para;</a></h4>
<p>@gozora</p>
<blockquote>
<p>Now the question remains how reliable/bulletproof this locking is.<br />
How it behaves if things go wrong?<br />
Can it be that that deadlocks occurs?<br />
It would not be much of a fun rebooting server because my DR solution
does not allow udev to operate with HW ;-)</p>
</blockquote>
<p>Good question. Deadlocks can IMO not occur because udev uses a
non-blocking lock. But one must be careful because udev tries to get a
shared (read) lock when processing an event related to the device, and
if it can not obtain the lock immediately, it skips processing of the
event, which causes events to be effectively lost (not a good design
IMO, but we can not do anything about it). See
<a href="https://github.com/openSUSE/multipath-tools/commit/841977fc9c3432702c296d6239e4a54291a6007a">https://github.com/openSUSE/multipath-tools/commit/841977fc9c3432702c296d6239e4a54291a6007a</a>.
In this case, problems should not cause "rebooting server because my DR
solution does not allow udev to operate with HW" as here we are in
restore, not in normal server operation, as @jsmeix pointed out. But
still, we should use a read (shared) lock for safety here
(<code>flock --shared</code>), which will not interfere with udev processing of the
events but still serializes partition table rereading (udev uses another
lock - an exclusive one - when rereading the partition table.)</p>
<h4 id="pcahyna_commented_at_2017-10-18_1646"><img src="https://avatars.githubusercontent.com/u/26300485?u=9105d243bc9f7ade463a3e52e8dd13fa67837158&v=4" width="50"><a href="https://github.com/pcahyna">pcahyna</a> commented at <a href="https://github.com/rear/rear/issues/793#issuecomment-337653905">2017-10-18 16:46</a>:<a class="headerlink" href="#pcahyna_commented_at_2017-10-18_1646" title="Permanent link">&para;</a></h4>
<p>@jsmeix</p>
<blockquote>
<p>I wonder if the flock default "waiting indefinitely for the lock<br />
to become available" is right.<br />
I think after a reasonable timeout ReaR should report something<br />
to the user ...</p>
</blockquote>
<p>I am not sure about it. Similar issue was found and fixed in ceph, see
<a href="https://github.com/ceph/ceph/pull/9330">https://github.com/ceph/ceph/pull/9330</a>
and I think it would be the safest to just do the same as they are doing
(call <code>udevadm settle</code> first and then retry partprobe under <code>flock -s</code>
(see my previous comment about the use of a shared lock) several times
if it fails). They sleep between retries just as in your solution.</p>
<hr />
<p>[Export of Github issue for
<a href="https://github.com/rear/rear">rear/rear</a>.]</p>
              
            </div>
          </div>

<footer>
  

  <hr/>

  <div role="contentinfo">
    <!-- Copyright etc -->
    
    <p>Copyright 2025 - CC0 1.0 Universal<br />Give <a href="https://github.com/rear/rear-user-guide/issues/new?title=issues/2016-03-08.793.issue.closed.html">feedback</a> on this page.</p>
    
  </div>
</footer>

        </div>
      </div>

    </section>

  </div>

  <div class="rst-versions" role="note" aria-label="Versions">
  <span class="rst-current-version" data-toggle="rst-current-version">
    
        <span>
          <a href="https://github.com/rear/rear-user-guide" class="fa fa-code-fork" style="color: #fcfcfc"> rear/rear-user-guide</a>
        </span>
    
    
    
  </span>
</div>
    <script src="../js/jquery-3.6.0.min.js"></script>
    <script>var base_url = "..";</script>
    <script src="../js/theme_extra.js"></script>
    <script src="../js/theme.js"></script>
      <script src="../search/main.js"></script>
    <script>
        jQuery(function () {
            SphinxRtdTheme.Navigation.enable(true);
        });
    </script>

</body>
</html>
