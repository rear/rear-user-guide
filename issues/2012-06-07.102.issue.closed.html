<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
    
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
      <link rel="shortcut icon" href="../img/favicon.ico" />
    <meta property="og:title" content="Relax-and-Recover (ReaR) User Guide Documentation"/>
    <meta property="og:description" content="This is an umbrella documentation project for all Relax-and-Recover (ReaR) kind of documentation ans starting with a good User Guide."/>
    <meta property="og:locale" content="en_US"/>
    <meta property="og:url" content="https://relax-and-recover.org/rear-user-guide/"/>
    <meta property="og:type" content="website"/>
    <meta property="og:image" content="https://relax-and-recover.org/rear-user-guide/img/rear_logo_50.png"/>
    <meta property="og:image:width" content="50"/>
    <meta property="og:image:height" content="50"/>
    
    <title>#102 Issue closed: Investigate "not properly aligned for best performance" - Relax-and-Recover (ReaR) User Guide Documentation</title>
    <link rel="stylesheet" href="../css/theme.css" />
    <link rel="stylesheet" href="../css/theme_extra.css" />
        <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/styles/github.min.css" />
        <link href="../css/rear.css" rel="stylesheet" />
    
      <script>
        // Current page data
        var mkdocs_page_name = "#102 Issue closed: Investigate \"not properly aligned for best performance\"";
        var mkdocs_page_input_path = "issues/2012-06-07.102.issue.closed.md";
        var mkdocs_page_url = null;
      </script>
    
    <!--[if lt IE 9]>
      <script src="../js/html5shiv.min.js"></script>
    <![endif]-->
      <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/highlight.min.js"></script>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/languages/yaml.min.js"></script>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/languages/rust.min.js"></script>
      <script>hljs.highlightAll();</script> 
      <script>
        (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
        (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
        m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
        })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

        ga('create', "366986045", "auto");
        ga('send', 'pageview');
      </script>
    
</head>

<body class="wy-body-for-nav" role="document">

  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side stickynav">
    <div class="wy-side-scroll">
      <div class="wy-side-nav-search">
          <a href="../index.html" class="icon icon-home"> Relax-and-Recover (ReaR) User Guide Documentation
        </a><div role="search">
  <form id ="rtd-search-form" class="wy-form" action="../search.html" method="get">
      <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" title="Type search term here" />
  </form>
</div>
      </div>

      <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <ul>
                <li class="toctree-l1"><a class="reference internal" href="../index.html">Relax-and-Recover (ReaR) User Guide Documentation</a>
                </li>
              </ul>
              <p class="caption"><span class="caption-text">WELCOME</span></p>
              <ul>
                  <li class="toctree-l1"><a class="reference internal" href="../welcome/index.html">Get started!</a>
                  </li>
              </ul>
              <p class="caption"><span class="caption-text">BASICS</span></p>
              <ul>
                  <li class="toctree-l1"><a class="reference internal" href="../basics/introduction.html">Introduction</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../basics/history.html">Bit of History</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../basics/getting-started.html">Getting started with ReaR</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../basics/configuration.html">Basic configuration</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../basics/backup_netfs.html">Example of BACKUP=NETFS</a>
                  </li>
              </ul>
              <p class="caption"><span class="caption-text">SCENARIOS</span></p>
              <ul>
                  <li class="toctree-l1"><a class="reference internal" href="../scenarios/index.html">Scenarios Overview</a>
                  </li>
              </ul>
              <p class="caption"><span class="caption-text">DEVELOPMENT</span></p>
              <ul>
                  <li class="toctree-l1"><a class="reference internal" href="../development/github-pr.html">Make a pull request with GitHub</a>
                  </li>
              </ul>
              <p class="caption"><span class="caption-text">RELEASE NOTES</span></p>
              <ul>
                  <li class="toctree-l1"><a class="reference internal" href="../releasenotes/index.html">Release Notes</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../releasenotes/rear29.html">Release Notes ReaR 2.9</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../releasenotes/rear28.html">Release Notes ReaR 2.8</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../releasenotes/rear27.html">Release Notes ReaR 2.7</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../releasenotes/rear26.html">Release Notes ReaR 2.6</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../releasenotes/knownproblems.html">Known Problems and Workarounds</a>
                  </li>
              </ul>
              <p class="caption"><span class="caption-text">ISSUES</span></p>
              <ul>
                  <li class="toctree-l1"><a class="reference internal" href="index.html">Issues History</a>
                  </li>
              </ul>
              <p class="caption"><span class="caption-text">LEGAL</span></p>
              <ul>
                  <li class="toctree-l1"><a class="reference internal" href="../legal/contributing/index.html">Contributing</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../legal/license/index.html">License</a>
                  </li>
              </ul>
      </div>
    </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">
      <nav class="wy-nav-top" role="navigation" aria-label="Mobile navigation menu">
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">Relax-and-Recover (ReaR) User Guide Documentation</a>
        
      </nav>
      <div class="wy-nav-content">
        <div class="rst-content"><div role="navigation" aria-label="breadcrumbs navigation">
  <ul class="wy-breadcrumbs">
    <li><a href="../index.html" class="icon icon-home" aria-label="Docs"></a></li>
      <li class="breadcrumb-item active">#102 Issue closed: Investigate "not properly aligned for best performance"</li>
    <li class="wy-breadcrumbs-aside">
    </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
            <div class="section" itemprop="articleBody">
              
                <h1 id="102_issue_closed_investigate_not_properly_aligned_for_best_performance"><a href="https://github.com/rear/rear/issues/102">#102 Issue</a> <code>closed</code>: Investigate "not properly aligned for best performance"<a class="headerlink" href="#102_issue_closed_investigate_not_properly_aligned_for_best_performance" title="Permanent link">&para;</a></h1>
<p><strong>Labels</strong>: <code>enhancement</code>, <code>bug</code>, <code>fixed / solved / done</code></p>
<h4 id="dagwieers_opened_issue_at_2012-06-07_0955"><img src="https://avatars.githubusercontent.com/u/388198?u=0732dee3fe5002278cfbf40359ec431bdcf5f06c&v=4" width="50"><a href="https://github.com/dagwieers">dagwieers</a> opened issue at <a href="https://github.com/rear/rear/issues/102">2012-06-07 09:55</a>:<a class="headerlink" href="#dagwieers_opened_issue_at_2012-06-07_0955" title="Permanent link">&para;</a></h4>
<p>When doing a <code>rear restore</code> parted complains about the fact that
partitions are not properly aligned. This might have a performance
impact on some hardware and therefor we need to make sure if parted is
correct in its claims and whether we should improve our logic (in those
cases where that's possible depending on parted version).</p>
<p>In my case I have seen this:</p>
<pre><code> +++ echo -e 'Creating partitions for disk /dev/sda (msdos)'
 +++ parted -s /dev/sda mklabel msdos
 +++ parted -s /dev/sda mkpart primary 32768B 542836735B
 Warning: The resulting partition is not properly aligned for best performance.
 +++ parted -s /dev/sda set 1 boot on
 +++ parted -s /dev/sda mkpart primary 542838784B 240057409535B
 Warning: The resulting partition is not properly aligned for best performance.
 +++ parted -s /dev/sda set 2 lvm on
</code></pre>
<p>Looking at the offsets, the main question is whether the offsets starts
at 0 or 1. Once we have determined what the correct start offset is, we
can make sure the offsets used are aligned on 4k boundaries. Here is an
example for the above boundaries:</p>
<pre><code>[root@moria ~]# echo alignment: $((32768%4096)) $((542836735%4096))
alignment: 0 2047
[root@moria ~]# echo alignment: $((542838784%4096)) $((240057409535%4096))
alignment: 0 4095
</code></pre>
<p>So in the above case, either the start offset, or the stop offset are
off-by-one. In essence, we should only be concerned by the start offset,
but we could do the right thing anyway.</p>
<h4 id="dagwieers_commented_at_2012-06-09_0035"><img src="https://avatars.githubusercontent.com/u/388198?u=0732dee3fe5002278cfbf40359ec431bdcf5f06c&v=4" width="50"><a href="https://github.com/dagwieers">dagwieers</a> commented at <a href="https://github.com/rear/rear/issues/102#issuecomment-6215808">2012-06-09 00:35</a>:<a class="headerlink" href="#dagwieers_commented_at_2012-06-09_0035" title="Permanent link">&para;</a></h4>
<p>Looking into this a bit closer, it's hard to know what properly aligned
means. According to some fora, if the EBS (Erase Block Size) is unknown,
using 512*1024 is a safe size to use. Looking at my offset:</p>
<pre><code>[root@moria rear]# parted /dev/sda unit b print
Model: ATA Corsair Force GT (scsi)
Disk /dev/sda: 240057409536B
Sector size (logical/physical): 512B/512B
Partition Table: msdos

Number  Start       End            Size           Type     File system  Flags
 1      32768B      542836735B     542803968B     primary  ext4         boot
 2      542838784B  240057409535B  239514570752B  primary               lvm
</code></pre>
<p>The first partition does not start at an erase block, but the second
partition does:</p>
<pre><code>[root@moria rear]# echo $((542838784%512*1024))
0
</code></pre>
<p>Still parted complained ?</p>
<h4 id="kpieth_commented_at_2015-10-17_1143"><img src="https://avatars.githubusercontent.com/u/1444692?v=4" width="50"><a href="https://github.com/kpieth">kpieth</a> commented at <a href="https://github.com/rear/rear/issues/102#issuecomment-148909408">2015-10-17 11:43</a>:<a class="headerlink" href="#kpieth_commented_at_2015-10-17_1143" title="Permanent link">&para;</a></h4>
<p>This is an important feature, because after a rear recovery you always
have unaligned Partitions and slow systems.<br />
Currently I always have to manually enter Starting Offsets before
recovery. The starting Position of the first partition is on my
Systems(HP Proliant, VMware, SSD Laptop) always Sector 2048 to get
proper alignment. A good explanation in german can be found here:<br />
<a href="https://www.thomas-krenn.com/de/wiki/Partition_Alignment">https://www.thomas-krenn.com/de/wiki/Partition_Alignment</a></p>
<h4 id="schlomo_commented_at_2015-10-17_1758"><img src="https://avatars.githubusercontent.com/u/101384?v=4" width="50"><a href="https://github.com/schlomo">schlomo</a> commented at <a href="https://github.com/rear/rear/issues/102#issuecomment-148938157">2015-10-17 17:58</a>:<a class="headerlink" href="#schlomo_commented_at_2015-10-17_1758" title="Permanent link">&para;</a></h4>
<p>@kpieth yes you are very right. Unfortunately nobody figured out an
automated way of doing this so far. Any ideas?</p>
<h4 id="jsmeix_commented_at_2015-10-19_0816"><img src="https://avatars.githubusercontent.com/u/1788608?u=925fc54e2ce01551392622446ece427f51e2f0ce&v=4" width="50"><a href="https://github.com/jsmeix">jsmeix</a> commented at <a href="https://github.com/rear/rear/issues/102#issuecomment-149139700">2015-10-19 08:16</a>:<a class="headerlink" href="#jsmeix_commented_at_2015-10-19_0816" title="Permanent link">&para;</a></h4>
<p>Only at a very quick first glance:</p>
<p>In the rear 1.17.2 sources I do not find any usage of "parted ...
--align=optimal"</p>
<p>It seems regardless that in
usr/share/rear/layout/prepare/GNU/Linux/10_include_partition_code.sh
a FEATURE_PARTED_ALIGNMENT exists, parted alignment is nowhere used.</p>
<p>I am not at all a sufficient parted expert to understand if "parted ...
--align=optimal" is actually the right solution here. The wording makes
it look as if it does "the right thing" but I do not (yet) know if it
actually does the right thing because
<a href="http://www.gnu.org/software/parted/manual/parted.html">http://www.gnu.org/software/parted/manual/parted.html</a>
is not really explanatory what actually happens for each of parted's
alignment types none, cylinder, minimal and optimal.</p>
<p>At least when YaST installs an openSUSE or SLE system it calls "parted
... --align=optimal", see also my script at "Generic disaster recovery
with the plain SUSE installation system" in
<a href="https://en.opensuse.org/SDB:Disaster_Recovery">https://en.opensuse.org/SDB:Disaster_Recovery</a>
how I call parted there (basicaly I copied it from how YaST calls
parted, see the comments in my script).</p>
<h4 id="jsmeix_commented_at_2015-10-19_0827"><img src="https://avatars.githubusercontent.com/u/1788608?u=925fc54e2ce01551392622446ece427f51e2f0ce&v=4" width="50"><a href="https://github.com/jsmeix">jsmeix</a> commented at <a href="https://github.com/rear/rear/issues/102#issuecomment-149141635">2015-10-19 08:27</a>:<a class="headerlink" href="#jsmeix_commented_at_2015-10-19_0827" title="Permanent link">&para;</a></h4>
<p>A general question:</p>
<p>Because at least low-end flash devices (a.k.a. USB sticks) require
alignment at 4MiB or even 8 MiB for not-too-bad performance (cf. my last
comment at
<a href="https://hackweek.suse.com/12/projects/23">https://hackweek.suse.com/12/projects/23</a>
) I wonder if rear should by default align at 4MiB or even 8 MiB - at
least when the partition size is much bigger than 4MiB or 8 MiB (e.g.
for partitions bigger that 100 MB).</p>
<p>This way a badly aligned original system could become even faster after
recovery. Is such a difference allowed or must rear recovery slavishly
produce a byte-by-byte identical copy whenever possible?</p>
<h4 id="schlomo_commented_at_2015-10-19_0917"><img src="https://avatars.githubusercontent.com/u/101384?v=4" width="50"><a href="https://github.com/schlomo">schlomo</a> commented at <a href="https://github.com/rear/rear/issues/102#issuecomment-149154570">2015-10-19 09:17</a>:<a class="headerlink" href="#schlomo_commented_at_2015-10-19_0917" title="Permanent link">&para;</a></h4>
<p>Wild guess: I am not sure if <code>--align=optimal</code> will have any effect as
long as we give <code>parted</code>exact Byte ranges as input. After all it would
have to change our precise input to make the alignment. Maybe part of
the problem is also to convert the math to work in MB so that
<code>parted</code>will have some leeway how to interpret the MB numbers.</p>
<h4 id="jsmeix_commented_at_2015-10-19_1021"><img src="https://avatars.githubusercontent.com/u/1788608?u=925fc54e2ce01551392622446ece427f51e2f0ce&v=4" width="50"><a href="https://github.com/jsmeix">jsmeix</a> commented at <a href="https://github.com/rear/rear/issues/102#issuecomment-149175705">2015-10-19 10:21</a>:<a class="headerlink" href="#jsmeix_commented_at_2015-10-19_1021" title="Permanent link">&para;</a></h4>
<p>Yes, that exact byte ranges as input for parted is what I question if
that is really reasonable (at least reasonable by default) to be done by
rear in my above comment regarding using 4MiB or even 8 MiB alignment by
default (for for sufficiently big partitions).</p>
<p>In other words: I wonder if rear should by default round exact byte
values to 4MiB or even 8 MiB chunks?</p>
<p>An obvious direct drawback is that a partition could become several MiB
smaller than it was before.</p>
<p>As an extreme example assume a 2020 MiB disk consists of 10 partitions
each with 202 MiB. Each is rounded to 4MiB resulting the first 9
partitions rounded to 204 MiB. As a consequence for the last partition
only 184 MiB = 2020 MiB - ( 9 * 204 MiB ) are available space on the
disk so that after recovery the 10. partition becomes 18 MiB = 9 * 2
MiB smaller than it was originally (i.e. about 10% smaller in this
example).</p>
<p>With GPT partitioning and 110 such 202 MiB partitions on a 22220 MiB
disk it is left to the reader to calculate that there would be no space
left on the device for the last partition.</p>
<h4 id="jsmeix_commented_at_2015-10-19_1050"><img src="https://avatars.githubusercontent.com/u/1788608?u=925fc54e2ce01551392622446ece427f51e2f0ce&v=4" width="50"><a href="https://github.com/jsmeix">jsmeix</a> commented at <a href="https://github.com/rear/rear/issues/102#issuecomment-149183504">2015-10-19 10:50</a>:<a class="headerlink" href="#jsmeix_commented_at_2015-10-19_1050" title="Permanent link">&para;</a></h4>
<p>@kpieth regarding<br />
<a href="https://www.thomas-krenn.com/de/wiki/Partition_Alignment">https://www.thomas-krenn.com/de/wiki/Partition_Alignment</a><br />
that reads (excerpt)</p>
<pre>
4 KiB / 8 KiB Pages der SSDs
</pre>

<p>I do not agree from my current point of understanding.</p>
<p>For flash strorage the physical block size for read/write operations is
usually something like 4MiB or 8MiB (mega bytes not kilo bytes!) cf. my
last comment in
<a href="https://hackweek.suse.com/12/projects/23">https://hackweek.suse.com/12/projects/23</a></p>
<p>I think SSDs usually have sufficiently intelligent controllers with
sufficiently huge caches built in so that small reads or writes could be
sufficiently well buffered - in particular consecutive small reads or
writes are combined by the controller into big reads or writes that mach
the physical block size of the actual storage hardware.</p>
<p>I think in the end for a sufficiently well made SSD it should not matter
too much how it is accessed or aligned.</p>
<p>In contrast I think for cheap flash-based storagae it does matter in
what chunks and with what alignment it is accessed.</p>
<p>But I am not at all a sufficient expert in this area to make really
authoritative statements.</p>
<p>I only think that 4 KiB alignment which should be the right one for
spinning traditional harddisks could be totally insufficient for cheap
flash based storage where 4 MiB or even 8 MiB would have to be used.</p>
<p>This is the reason why I am thinking about using 4 MiB or even 8 MiB
alingnment by default in rear for sufficiently big partitions (i.e.
where rounding differences should not matter in reasonable scenarios).</p>
<h4 id="jsmeix_commented_at_2015-10-20_1158"><img src="https://avatars.githubusercontent.com/u/1788608?u=925fc54e2ce01551392622446ece427f51e2f0ce&v=4" width="50"><a href="https://github.com/jsmeix">jsmeix</a> commented at <a href="https://github.com/rear/rear/issues/102#issuecomment-149540958">2015-10-20 11:58</a>:<a class="headerlink" href="#jsmeix_commented_at_2015-10-20_1158" title="Permanent link">&para;</a></h4>
<p>Wait!<br />
Going back to square one:</p>
<p>I verified that with "rear recover" (using rear 1.17.2)<br />
one gets a byte-by-byte identical copy of the partitioning<br />
of the original disk:</p>
<p>My original system disk:</p>
<pre>
# parted -s /dev/sda unit B print
Model: ATA QEMU HARDDISK (scsi)
Disk /dev/sda: 26843545600B
Sector size (logical/physical): 512B/512B
Partition Table: msdos
Disk Flags: 
Number  Start         End           Size          Type     File system     Flags
 1      1048576B      1570766847B   1569718272B   primary  linux-swap(v1)  type=82
 2      1570766848B   14459863039B  12889096192B  primary  btrfs           boot, type=83
 3      14459863040B  26843545599B  12383682560B  primary  xfs             type=83
</pre>

<p>My recovered system disk on a identical second machine:</p>
<pre>
# parted -s /dev/sda unit B print
Model: ATA QEMU HARDDISK (scsi)
Disk /dev/sda: 26843545600B
Sector size (logical/physical): 512B/512B
Partition Table: msdos
Disk Flags: 
Number  Start         End           Size          Type     File system     Flags
 1      1048576B      1570766847B   1569718272B   primary  linux-swap(v1)  type=83
 2      1570766848B   14459863039B  12889096192B  primary  btrfs           boot, type=83
 3      14459863040B  26843545599B  12383682560B  primary  xfs             type=83
</pre>

<p>This means when after "rear recover" the partitions are badly aligned,<br />
they must have been already badly aligned on the original system.</p>
<p>I think it does not belong to rear to somehow try to fix badly aligned<br />
partitions.</p>
<p>Or do I misunderstand something so that it can happen<br />
that well aligned partitions on the original system become<br />
badly aligned partitions after "rear recover"?</p>
<p>@kpieth<br />
please provide the output of</p>
<pre>
# parted -s /dev/sdX unit B print
</pre>

<p>(replaxe 'X' with what is appropriate for your harddisk)<br />
both on your original system and after "rear recover".</p>
<h4 id="jhoekx_commented_at_2015-10-20_1229"><img src="https://avatars.githubusercontent.com/u/783473?v=4" width="50"><a href="https://github.com/jhoekx">jhoekx</a> commented at <a href="https://github.com/rear/rear/issues/102#issuecomment-149550235">2015-10-20 12:29</a>:<a class="headerlink" href="#jhoekx_commented_at_2015-10-20_1229" title="Permanent link">&para;</a></h4>
<p>When I was working on the partitioning code, the goal was to reuse the
exact same offsets if no resizing had to be done. As soon as we enter
migration mode, the code tried to align on boundaries.</p>
<p>It would be interesting to know if we are in migration mode or not?</p>
<p>Maybe the choice of boundaries is not optimal?</p>
<h4 id="kpieth_commented_at_2015-10-23_2205"><img src="https://avatars.githubusercontent.com/u/1444692?v=4" width="50"><a href="https://github.com/kpieth">kpieth</a> commented at <a href="https://github.com/rear/rear/issues/102#issuecomment-150703886">2015-10-23 22:05</a>:<a class="headerlink" href="#kpieth_commented_at_2015-10-23_2205" title="Permanent link">&para;</a></h4>
<p>Yes we are talking about migration mode. A well aligned partition gets
bad aligned after rear recovery. If no resizing is done, everything is
at it was. We use rear for installing new machines(VM and Hardware). My
machines usually run virtualized and so have several layers of storage
under it. Alignment really has a performance impact.</p>
<h4 id="gdha_commented_at_2016-09-07_1449"><img src="https://avatars.githubusercontent.com/u/888633?u=cdaeb31efcc0048d3619651aa18dd4b76e636b21&v=4" width="50"><a href="https://github.com/gdha">gdha</a> commented at <a href="https://github.com/rear/rear/issues/102#issuecomment-245304986">2016-09-07 14:49</a>:<a class="headerlink" href="#gdha_commented_at_2016-09-07_1449" title="Permanent link">&para;</a></h4>
<p>added it to the sponsor list - close it</p>
<h4 id="jsmeix_commented_at_2018-02-13_1145"><img src="https://avatars.githubusercontent.com/u/1788608?u=925fc54e2ce01551392622446ece427f51e2f0ce&v=4" width="50"><a href="https://github.com/jsmeix">jsmeix</a> commented at <a href="https://github.com/rear/rear/issues/102#issuecomment-365243334">2018-02-13 11:45</a>:<a class="headerlink" href="#jsmeix_commented_at_2018-02-13_1145" title="Permanent link">&para;</a></h4>
<p>Right now the following is mainly only an offhanded guess<br />
but perhaps I may have found the root cause of this issue:</p>
<p>With bigger replacement disk size one gets partitions recreated<br />
with some automatically resized partitions via<br />
usr/share/rear/layout/prepare/default/400_autoresize_disks.sh<br />
which evenly distribute the size changes on byte values so that<br />
the automatically resized partitions can be arbitrarily badly aligned.</p>
<p>Later some partition alignment happens in<br />
usr/share/rear/layout/prepare/GNU/Linux/100_include_partition_code.sh<br />
where my offhanded guess is the alignment is something like 1 MiB<br />
because of the '/ 1024 / 1024' in the code<br />
but perhaps one may even get only 1 Byte as alignment<br />
in case of FEATURE_PARTED_ANYUNIT which may finally<br />
explain the root cause behind this issue.</p>
<p>Summary from my current point of view:</p>
<p>With same replacement disk size one gets partitions recreated<br />
at the exact same byte values as they have been on the original system<br />
which is the right behaviour because ReaR is first and foremost meant<br />
to recreate a system as much as possible exactly as it was before.</p>
<p>In contrast with bigger replacement disk size one may get<br />
automatically resized partitions that can be arbitrarily badly aligned.</p>
<p>I think even with bigger replacement disk size the default should also
be<br />
to get partitions recreated at the exact same byte values<br />
as they have been on the original system so that by default one gets<br />
the system recreated as much as possible exactly as it was before.</p>
<p>Optionally - only after a user confirmation dialog - with bigger
replacement disk size<br />
one could get automatically resized partitions but then with a
specific<br />
alignment value PARTITION_ALIGN_BLOCK_SIZE that is by default<br />
the same as USB_PARTITION_ALIGN_BLOCK_SIZE i.e. 8 MiB<br />
to create things reasonably right out of the box also on SSDs, cf.<br />
<a href="https://github.com/rear/rear/issues/1201">https://github.com/rear/rear/issues/1201</a></p>
<h4 id="jsmeix_commented_at_2018-02-16_1402"><img src="https://avatars.githubusercontent.com/u/1788608?u=925fc54e2ce01551392622446ece427f51e2f0ce&v=4" width="50"><a href="https://github.com/jsmeix">jsmeix</a> commented at <a href="https://github.com/rear/rear/issues/102#issuecomment-366243032">2018-02-16 14:02</a>:<a class="headerlink" href="#jsmeix_commented_at_2018-02-16_1402" title="Permanent link">&para;</a></h4>
<p>In my current
<a href="https://github.com/rear/rear/pull/1733">https://github.com/rear/rear/pull/1733</a><br />
I do not implement any PARTITION_ALIGN_BLOCK_SIZE support<br />
because I think this is not needed when only the end value<br />
of the last partition on each disk may get changed<br />
(I use a hardcoded 1 MiB alignment for the partition end values)<br />
for details see
<a href="https://github.com/rear/rear/pull/1733">https://github.com/rear/rear/pull/1733</a></p>
<h4 id="jsmeix_commented_at_2018-02-21_1230"><img src="https://avatars.githubusercontent.com/u/1788608?u=925fc54e2ce01551392622446ece427f51e2f0ce&v=4" width="50"><a href="https://github.com/jsmeix">jsmeix</a> commented at <a href="https://github.com/rear/rear/issues/102#issuecomment-367311319">2018-02-21 12:30</a>:<a class="headerlink" href="#jsmeix_commented_at_2018-02-21_1230" title="Permanent link">&para;</a></h4>
<p>Only FYI:</p>
<p>Right now it happened to me that I got such a parted<br />
"Warning: The resulting partition is not properly aligned for best
performance.".</p>
<p>In my case it happened this way:</p>
<pre>
# parted -s /dev/sdb unit MiB print
Model: ATA QEMU HARDDISK (scsi)
Disk /dev/sdb: 2048MiB
Sector size (logical/physical): 512B/512B
Partition Table: msdos
Number  Start    End      Size    Type      File system     Flags
 1      8.00MiB  808MiB   800MiB  primary   ext2            type=83
 2      808MiB   1208MiB  400MiB  primary   linux-swap(v1)  type=82
 3      1208MiB  1708MiB  500MiB  extended                  lba, type=0f

# parted -s -a optimal /dev/sdb unit MiB mkpart logical 1208 1408
Warning: The resulting partition is not properly aligned for best performance.

# parted -s /dev/sdb unit MiB print
Model: ATA QEMU HARDDISK (scsi)
Disk /dev/sdb: 2048MiB
Sector size (logical/physical): 512B/512B
Partition Table: msdos
Number  Start    End      Size    Type      File system     Flags
 1      8.00MiB  808MiB   800MiB  primary   ext2            type=83
 2      808MiB   1208MiB  400MiB  primary   linux-swap(v1)  type=82
 3      1208MiB  1708MiB  500MiB  extended                  lba, type=0f
 5      1208MiB  1408MiB  200MiB  logical                   type=83

# parted -s /dev/sdb unit B print
Model: ATA QEMU HARDDISK (scsi)
Disk /dev/sdb: 2147483648B
Sector size (logical/physical): 512B/512B
Partition Table: msdos
Number  Start        End          Size        Type      File system     Flags
 1      8388608B     847249407B   838860800B  primary   ext2            type=83
 2      847249408B   1266679807B  419430400B  primary   linux-swap(v1)  type=82
 3      1266679808B  1790967807B  524288000B  extended                  lba, type=0f
 5      1266680320B  1476395519B  209715200B  logical                   type=83

# echo '1208 * 1024 * 1024' | bc -l
1266679808

# echo '1266680320 / 1024 / 1024' | bc -l
1208.00048828125000000000

# echo '1266680320 - 1266679808' | bc -l
512
</pre>

<p>I had specified the logical partition start with 1 MiB unit<br />
at the same point where the extended partition starts<br />
but parted knows that the first sector (i.e. the first 512 bytes)<br />
of the extended partition cannot be used by the logical partition<br />
so that parted automatically moved the actual logical partition start<br />
by only 512 bytes which results an actual logical partition start
point<br />
that is "not properly aligned for best performance"<br />
(whatever that exactly means in parted's opinion - see next paragraph)<br />
and - as far as I know - there should be an at least 63 sectors gap<br />
(i.e. at least 63 * 512 bytes = 32256 bytes) gap between the<br />
extended partition start and the first logical partition start.</p>
<p>I think when parted can make such a "Warning" message<br />
cf.
<a href="http://blog.schlomo.schapiro.org/2015/04/warning-is-waste-of-my-time.html">http://blog.schlomo.schapiro.org/2015/04/warning-is-waste-of-my-time.html</a><br />
parted must have some built-in "knowledge" what would be<br />
"properly aligned for best performance" and then I wonder why<br />
parted does not automatically align it "properly for best performance"<br />
regardless that I had explicitly called parted with <code>-a optimal</code><br />
i.e. what the heck is parted's alignment type <code>optimal</code> meant for?</p>
<p>When I manually specify the logical partition start with 1 MiB unit<br />
at one MiB more from where the extended partition starts it works:</p>
<pre>
# parted -s /dev/sdb rm 5

# parted -s /dev/sdb unit MiB mkpart logical 1209 1408

# parted -s /dev/sdb unit MiB print
Model: ATA QEMU HARDDISK (scsi)
Disk /dev/sdb: 2048MiB
Sector size (logical/physical): 512B/512B
Partition Table: msdos
Number  Start    End      Size    Type      File system     Flags
 1      8.00MiB  808MiB   800MiB  primary   ext2            type=83
 2      808MiB   1208MiB  400MiB  primary   linux-swap(v1)  type=82
 3      1208MiB  1708MiB  500MiB  extended                  lba, type=0f
 5      1209MiB  1408MiB  199MiB  logical                   type=83

# parted -s /dev/sdb unit B print
Model: ATA QEMU HARDDISK (scsi)
Disk /dev/sdb: 2147483648B
Sector size (logical/physical): 512B/512B
Partition Table: msdos
Number  Start        End          Size        Type      File system     Flags
 1      8388608B     847249407B   838860800B  primary   ext2            type=83
 2      847249408B   1266679807B  419430400B  primary   linux-swap(v1)  type=82
 3      1266679808B  1790967807B  524288000B  extended                  lba, type=0f
 5      1267728384B  1476395007B  208666624B  logical                   type=83

# echo '1267728384 / 1024 / 1024' | bc -l
1209.00000000000000000000
</pre>

<p>Lesson learned:</p>
<p>Do not rely on parted's automated alignment<br />
(in particular do not rely on parted's <code>optimal</code> alignment)<br />
but calculate the right values manually and<br />
use the right values in parted calls.</p>
<h4 id="jsmeix_commented_at_2018-02-23_1450"><img src="https://avatars.githubusercontent.com/u/1788608?u=925fc54e2ce01551392622446ece427f51e2f0ce&v=4" width="50"><a href="https://github.com/jsmeix">jsmeix</a> commented at <a href="https://github.com/rear/rear/issues/102#issuecomment-368030088">2018-02-23 14:50</a>:<a class="headerlink" href="#jsmeix_commented_at_2018-02-23_1450" title="Permanent link">&para;</a></h4>
<p>I think<br />
<a href="https://github.com/rear/rear/pull/1733#issuecomment-367680598">https://github.com/rear/rear/pull/1733#issuecomment-367680598</a><br />
and<br />
<a href="https://github.com/rear/rear/pull/1733#issuecomment-368028494">https://github.com/rear/rear/pull/1733#issuecomment-368028494</a><br />
prove that "rear recover" at least in migration mode<br />
can result a changed and badly aligned partitioning.</p>
<h4 id="jsmeix_commented_at_2018-03-01_1347"><img src="https://avatars.githubusercontent.com/u/1788608?u=925fc54e2ce01551392622446ece427f51e2f0ce&v=4" width="50"><a href="https://github.com/jsmeix">jsmeix</a> commented at <a href="https://github.com/rear/rear/issues/102#issuecomment-369596346">2018-03-01 13:47</a>:<a class="headerlink" href="#jsmeix_commented_at_2018-03-01_1347" title="Permanent link">&para;</a></h4>
<p>With
<a href="https://github.com/rear/rear/pull/1733">https://github.com/rear/rear/pull/1733</a>
merged<br />
this issue should be (hopefully) fixed, cf.<br />
<a href="https://github.com/rear/rear/pull/1733#issuecomment-369514406">https://github.com/rear/rear/pull/1733#issuecomment-369514406</a></p>
<p>But this means there is now a changed default behaviour<br />
how ReaR behaves in migration mode when partitions can or must be<br />
resized to fit on replacement disks with different size, cf. the merge
commit comment<br />
<a href="https://github.com/rear/rear/commit/6414936ba30d6c13020eee8313e93a4e29debc54">https://github.com/rear/rear/commit/6414936ba30d6c13020eee8313e93a4e29debc54</a></p>
<hr />
<p>[Export of Github issue for
<a href="https://github.com/rear/rear">rear/rear</a>.]</p>
              
            </div>
          </div>

<footer>
  

  <hr/>

  <div role="contentinfo">
    <!-- Copyright etc -->
    
    <p>Copyright 2025 - CC0 1.0 Universal<br />Give <a href="https://github.com/rear/rear-user-guide/issues/new?title=issues/2012-06-07.102.issue.closed.html">feedback</a> on this page.</p>
    
  </div>
</footer>

        </div>
      </div>

    </section>

  </div>

  <div class="rst-versions" role="note" aria-label="Versions">
  <span class="rst-current-version" data-toggle="rst-current-version">
    
        <span>
          <a href="https://github.com/rear/rear-user-guide" class="fa fa-code-fork" style="color: #fcfcfc"> rear/rear-user-guide</a>
        </span>
    
    
    
  </span>
</div>
    <script src="../js/jquery-3.6.0.min.js"></script>
    <script>var base_url = "..";</script>
    <script src="../js/theme_extra.js"></script>
    <script src="../js/theme.js"></script>
      <script src="../search/main.js"></script>
    <script>
        jQuery(function () {
            SphinxRtdTheme.Navigation.enable(true);
        });
    </script>

</body>
</html>
