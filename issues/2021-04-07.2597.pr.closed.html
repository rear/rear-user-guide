<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
    
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
      <link rel="shortcut icon" href="../img/favicon.ico" />
    <meta property="og:title" content="Relax-and-Recover (ReaR) User Guide Documentation"/>
    <meta property="og:description" content="This is an umbrella documentation project for all Relax-and-Recover (ReaR) kind of documentation ans starting with a good User Guide."/>
    <meta property="og:locale" content="en_US"/>
    <meta property="og:url" content="https://relax-and-recover.org/rear-user-guide/"/>
    <meta property="og:type" content="website"/>
    <meta property="og:image" content="https://relax-and-recover.org/rear-user-guide/img/rear_logo_50.png"/>
    <meta property="og:image:width" content="50"/>
    <meta property="og:image:height" content="50"/>
    
    <title>#2597 PR closed: New ONLY_INCLUDE_DISKS variable - Relax-and-Recover (ReaR) User Guide Documentation</title>
    <link rel="stylesheet" href="../css/theme.css" />
    <link rel="stylesheet" href="../css/theme_extra.css" />
        <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/styles/github.min.css" />
        <link href="../css/rear.css" rel="stylesheet" />
    
      <script>
        // Current page data
        var mkdocs_page_name = "#2597 PR closed: New ONLY_INCLUDE_DISKS variable";
        var mkdocs_page_input_path = "issues/2021-04-07.2597.pr.closed.md";
        var mkdocs_page_url = null;
      </script>
    
    <!--[if lt IE 9]>
      <script src="../js/html5shiv.min.js"></script>
    <![endif]-->
      <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/highlight.min.js"></script>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/languages/yaml.min.js"></script>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/languages/rust.min.js"></script>
      <script>hljs.highlightAll();</script> 
      <script>
        (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
        (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
        m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
        })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

        ga('create', "366986045", "auto");
        ga('send', 'pageview');
      </script>
    
</head>

<body class="wy-body-for-nav" role="document">

  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side stickynav">
    <div class="wy-side-scroll">
      <div class="wy-side-nav-search">
          <a href="../index.html" class="icon icon-home"> Relax-and-Recover (ReaR) User Guide Documentation
        </a><div role="search">
  <form id ="rtd-search-form" class="wy-form" action="../search.html" method="get">
      <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" title="Type search term here" />
  </form>
</div>
      </div>

      <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <ul>
                <li class="toctree-l1"><a class="reference internal" href="../index.html">Relax-and-Recover (ReaR) User Guide Documentation</a>
                </li>
              </ul>
              <p class="caption"><span class="caption-text">WELCOME</span></p>
              <ul>
                  <li class="toctree-l1"><a class="reference internal" href="../welcome/index.html">Get started!</a>
                  </li>
              </ul>
              <p class="caption"><span class="caption-text">BASICS</span></p>
              <ul>
                  <li class="toctree-l1"><a class="reference internal" href="../basics/introduction.html">Introduction</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../basics/history.html">Bit of History</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../basics/getting-started.html">Getting started with ReaR</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../basics/configuration.html">Basic configuration</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../basics/backup_netfs.html">Example of BACKUP=NETFS</a>
                  </li>
              </ul>
              <p class="caption"><span class="caption-text">SCENARIOS</span></p>
              <ul>
                  <li class="toctree-l1"><a class="reference internal" href="../scenarios/index.html">Scenarios Overview</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../scenarios/netfs_nas.html">Internal Backup with tar to NFS server</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../scenarios/netfs_rsync.html">Internal Backup with rsync to NFS server</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../scenarios/rsync.html">External Backup using BACKUP=RSYNC method</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../scenarios/rbme.html">External Backup using RBME</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../scenarios/restic.html">External Backup using restic</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../scenarios/duplicity.html">External Backup using duplicity</a>
                  </li>
              </ul>
              <p class="caption"><span class="caption-text">DEVELOPMENT</span></p>
              <ul>
                  <li class="toctree-l1"><a class="reference internal" href="../development/github-pr.html">Make a pull request with GitHub</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../development/squash-git-log-commments.html">How to squash git log comments into one line</a>
                  </li>
              </ul>
              <p class="caption"><span class="caption-text">RELEASE NOTES</span></p>
              <ul>
                  <li class="toctree-l1"><a class="reference internal" href="../releasenotes/index.html">Release Notes</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../releasenotes/rear29.html">Release Notes ReaR 2.9</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../releasenotes/rear28.html">Release Notes ReaR 2.8</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../releasenotes/rear27.html">Release Notes ReaR 2.7</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../releasenotes/rear26.html">Release Notes ReaR 2.6</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../releasenotes/knownproblems.html">Known Problems and Workarounds</a>
                  </li>
              </ul>
              <p class="caption"><span class="caption-text">ISSUES</span></p>
              <ul>
                  <li class="toctree-l1"><a class="reference internal" href="index.html">Issues History</a>
                  </li>
              </ul>
              <p class="caption"><span class="caption-text">LEGAL</span></p>
              <ul>
                  <li class="toctree-l1"><a class="reference internal" href="../legal/contributing/index.html">Contributing</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../legal/license/index.html">License</a>
                  </li>
              </ul>
      </div>
    </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">
      <nav class="wy-nav-top" role="navigation" aria-label="Mobile navigation menu">
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">Relax-and-Recover (ReaR) User Guide Documentation</a>
        
      </nav>
      <div class="wy-nav-content">
        <div class="rst-content"><div role="navigation" aria-label="breadcrumbs navigation">
  <ul class="wy-breadcrumbs">
    <li><a href="../index.html" class="icon icon-home" aria-label="Docs"></a></li>
      <li class="breadcrumb-item active">#2597 PR closed: New ONLY_INCLUDE_DISKS variable</li>
    <li class="wy-breadcrumbs-aside">
    </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
            <div class="section" itemprop="articleBody">
              
                <h1 id="2597_pr_closed_new_only_include_disks_variable"><a href="https://github.com/rear/rear/pull/2597">#2597 PR</a> <code>closed</code>: New ONLY_INCLUDE_DISKS variable<a class="headerlink" href="#2597_pr_closed_new_only_include_disks_variable" title="Permanent link">&para;</a></h1>
<p><strong>Labels</strong>: <code>enhancement</code>, <code>discuss / RFC</code>, <code>no-pr-activity</code></p>
<h4 id="rmetrich_opened_issue_at_2021-04-07_0815"><img src="https://avatars.githubusercontent.com/u/1163635?u=36b5e32e1dd55f1ce77cad431a5683fce40a7934&v=4" width="50"><a href="https://github.com/rmetrich">rmetrich</a> opened issue at <a href="https://github.com/rear/rear/pull/2597">2021-04-07 08:15</a>:<a class="headerlink" href="#rmetrich_opened_issue_at_2021-04-07_0815" title="Permanent link">&para;</a></h4>
<h4 id="relax-and-recover_rear_pull_request_template">Relax-and-Recover (ReaR) Pull Request Template<a class="headerlink" href="#relax-and-recover_rear_pull_request_template" title="Permanent link">&para;</a></h4>
<p>Please fill in the following items before submitting a new pull request:</p>
<h5 id="pull_request_details">Pull Request Details:<a class="headerlink" href="#pull_request_details" title="Permanent link">&para;</a></h5>
<ul>
<li>
<p>Type: <strong>Enhancement</strong></p>
</li>
<li>
<p>Impact: <strong>Normal</strong></p>
</li>
<li>
<p>Reference to related issue (URL): None</p>
</li>
<li>
<p>How was this pull request tested?</p>
</li>
</ul>
<p>Tested on multipath hardware from a customer. Saved 40 minutes creating
the Rescue ISO.</p>
<ul>
<li>Brief description of the changes in this pull request:</li>
</ul>
<p>This array variable enables to only process specified disks when
building the <code>disklayout.conf</code> file.<br />
This is particularly useful when having a lot of multipath devices which
are slow to scan but anyway excluded in the end.</p>
<p>This is for experts only, since it may end up creating an inconsistent
<code>disklayout.conf</code> file.<br />
In particular the <code>EXCLUDE_MOUNTPOINTS</code> variable is not populated
automatically because doing so would likely break things.</p>
<p>Usage example:</p>
<pre><code>ONLY_INCLUDE_DISKS=( sda sdb )
</code></pre>
<p>or</p>
<pre><code>ONLY_INCLUDE_DISKS=( /sys/block/sda )
</code></pre>
<h4 id="pcahyna_commented_at_2021-04-07_0834"><img src="https://avatars.githubusercontent.com/u/26300485?u=9105d243bc9f7ade463a3e52e8dd13fa67837158&v=4" width="50"><a href="https://github.com/pcahyna">pcahyna</a> commented at <a href="https://github.com/rear/rear/pull/2597#issuecomment-814720370">2021-04-07 08:34</a>:<a class="headerlink" href="#pcahyna_commented_at_2021-04-07_0834" title="Permanent link">&para;</a></h4>
<p>While saving 40 minutes in mkrescue sounds attractive, I am not sure
whether adding yet another knob, especially one that "is for experts
only, since it may end up creating an inconsistent disklayout.conf
file." is the way to go.</p>
<p>Would it be possible to do the optimization automatically by scanning
only the disks actually referenced by the objects (filesystems, VGs)
that one wants to include in the backup and avoid even looking at those
that are not referenced?</p>
<h4 id="gdha_commented_at_2021-04-07_1135"><img src="https://avatars.githubusercontent.com/u/888633?u=cdaeb31efcc0048d3619651aa18dd4b76e636b21&v=4" width="50"><a href="https://github.com/gdha">gdha</a> commented at <a href="https://github.com/rear/rear/pull/2597#issuecomment-814842705">2021-04-07 11:35</a>:<a class="headerlink" href="#gdha_commented_at_2021-04-07_1135" title="Permanent link">&para;</a></h4>
<p>@rmetrich could you via ONLY_INCLUDE_VG variable not exclude all other
block devices? I'm afraid that the new ONLY_INCLUDE_DISKS variable
will lead to more confusion by the end-users? And, when both are used
and remove a disk that should not? We must be careful with exclude and
include rules - less is better IMHO</p>
<h4 id="rmetrich_commented_at_2021-04-07_1139"><img src="https://avatars.githubusercontent.com/u/1163635?u=36b5e32e1dd55f1ce77cad431a5683fce40a7934&v=4" width="50"><a href="https://github.com/rmetrich">rmetrich</a> commented at <a href="https://github.com/rear/rear/pull/2597#issuecomment-814844804">2021-04-07 11:39</a>:<a class="headerlink" href="#rmetrich_commented_at_2021-04-07_1139" title="Permanent link">&para;</a></h4>
<p>@gdha yes it's not perfect for sure. The issue with
<strong>ONLY_INCLUDE_VG</strong> is that this doesn't prevent scanning the devices,
because all the code is flowing from bottom up, hence first scan
devices, then exclude stuff.<br />
Whereas we would need here to do the opposite: include vg, know how a vg
is created, then go down to selecting devices.</p>
<h4 id="jsmeix_commented_at_2021-04-07_1302"><img src="https://avatars.githubusercontent.com/u/1788608?u=925fc54e2ce01551392622446ece427f51e2f0ce&v=4" width="50"><a href="https://github.com/jsmeix">jsmeix</a> commented at <a href="https://github.com/rear/rear/pull/2597#issuecomment-814895323">2021-04-07 13:02</a>:<a class="headerlink" href="#jsmeix_commented_at_2021-04-07_1302" title="Permanent link">&para;</a></h4>
<p>Caution!<br />
Long and elaborated text about generic things:</p>
<p>As far as I see the whole include/exclude area<br />
has become a grown "hairy" mess over the time, cf.<br />
<a href="https://github.com/rear/rear/issues/2229#issuecomment-531264805">https://github.com/rear/rear/issues/2229#issuecomment-531264805</a></p>
<p>Usually (i.e. in commonly used and tested cases) things work well.<br />
But in special and/or exceptional cases things fall apart and what is
worst:<br />
Currently (as far as I see) there is no simple clear and consistently
working way<br />
how the user could specify what disk layout components he wants to get
recreated<br />
and what mountpoints or directories he wants to get included in the
backup.</p>
<p>Including/excluding components like disks/partitions/filesystems<br />
is different from what gets included/excluded in the backup.<br />
There are some relationships but in general both are different things.</p>
<p>See<br />
<a href="https://github.com/rear/rear/issues/2586#issuecomment-805601063">https://github.com/rear/rear/issues/2586#issuecomment-805601063</a><br />
and the therein linked comments in<br />
<a href="https://github.com/rear/rear/issues/2229">https://github.com/rear/rear/issues/2229</a><br />
and also<br />
<a href="https://github.com/rear/rear/issues/2236#issuecomment-531204474">https://github.com/rear/rear/issues/2236#issuecomment-531204474</a><br />
which is also a special case for multipath.</p>
<p>For ReaR's internal BACKUP method I added some time ago<br />
BACKUP_ONLY_INCLUDE and BACKUP_ONLY_EXCLUDE<br />
cf.
<a href="https://github.com/rear/rear/pull/1091">https://github.com/rear/rear/pull/1091</a><br />
so that the user could specify what he wants to get in his backup<br />
by keeping ReaR's automatisms out of his way.</p>
<p>Currently there is no counterpart for the disk layout like<br />
where the user could specify what he wants to get in his
disklayout.conf<br />
by keeping ReaR's automatisms out of his way.</p>
<p>The problem with including/excluding disk layout components<br />
are their interdependencies.</p>
<p>I think the following comment in disklayout.conf<br />
<a href="https://github.com/rear/rear/blob/master/usr/share/rear/conf/default.conf#L2749">https://github.com/rear/rear/blob/master/usr/share/rear/conf/default.conf#L2749</a></p>
<pre><code># How to exclude something ----- EXCLUDES -------
#
# You cannot exclude a device (e.g. /dev/sdg) directly.
# Instead you have to exclude everything ON that device
# and then the dependency tracker will automatically exclude
# the device from the recovery (because there won't be any
# recovery information for that "unnecessary" device).
#
# Furthermore, you have to exclude MD devices and LVM2
# volume groups separately as there is no automatic detection
# of these dependencies.
</code></pre>
<p>points to the root cause why the disk layout components<br />
include/exclude functionality in ReaR behaves "hairy":</p>
<p>It is ReaR's automatisms that<br />
on the one hand make things work well in commonly used and tested
cases<br />
BUT<br />
on the other hand it let things fall apart in special and/or exceptional
cases<br />
(because not automatism can behave perfectly for all use cases).</p>
<p>I think I need to sleep over it to let a reasonable opinion appear<br />
whether or not I like a new ONLY_INCLUDE_DISKS config variable.</p>
<p>In general I want "final power to the user" so in general<br />
I like when the user can switch off ReaR's automatisms<br />
and command ReaR what it must do (where the user takes<br />
full responsibility for what he commands - of course).</p>
<h4 id="jsmeix_commented_at_2021-04-07_1309"><img src="https://avatars.githubusercontent.com/u/1788608?u=925fc54e2ce01551392622446ece427f51e2f0ce&v=4" width="50"><a href="https://github.com/jsmeix">jsmeix</a> commented at <a href="https://github.com/rear/rear/pull/2597#issuecomment-814899754">2021-04-07 13:09</a>:<a class="headerlink" href="#jsmeix_commented_at_2021-04-07_1309" title="Permanent link">&para;</a></h4>
<p>@rmetrich<br />
could you provide what</p>
<pre><code># find /sys/block -ls

# lsblk -ipo NAME,KNAME,PKNAME,TRAN,TYPE,FSTYPE,SIZE,MOUNTPOINT
</code></pre>
<p>results on such a machine with a lot of multipath devices?<br />
I really have no idea what "a lot of multipath devices" actually
means.<br />
Are there tens or hundreds or thousands?</p>
<h4 id="rmetrich_commented_at_2021-04-07_1318"><img src="https://avatars.githubusercontent.com/u/1163635?u=36b5e32e1dd55f1ce77cad431a5683fce40a7934&v=4" width="50"><a href="https://github.com/rmetrich">rmetrich</a> commented at <a href="https://github.com/rear/rear/pull/2597#issuecomment-814908043">2021-04-07 13:18</a>:<a class="headerlink" href="#rmetrich_commented_at_2021-04-07_1318" title="Permanent link">&para;</a></h4>
<p>First *<em>dm-XX</em> nodes:</p>
<pre><code>lrwxrwxrwx. 1 root root 0  6. Apr 09:24 dm-0 -&gt; ../devices/virtual/block/dm-0
lrwxrwxrwx. 1 root root 0  6. Apr 09:24 dm-1 -&gt; ../devices/virtual/block/dm-1
lrwxrwxrwx. 1 root root 0  6. Apr 16:53 dm-10 -&gt; ../devices/virtual/block/dm-10
lrwxrwxrwx. 1 root root 0  6. Apr 16:54 dm-100 -&gt; ../devices/virtual/block/dm-100
lrwxrwxrwx. 1 root root 0  6. Apr 17:00 dm-101 -&gt; ../devices/virtual/block/dm-101
lrwxrwxrwx. 1 root root 0  6. Apr 16:54 dm-102 -&gt; ../devices/virtual/block/dm-102
lrwxrwxrwx. 1 root root 0  6. Apr 17:00 dm-103 -&gt; ../devices/virtual/block/dm-103
lrwxrwxrwx. 1 root root 0  6. Apr 16:54 dm-104 -&gt; ../devices/virtual/block/dm-104
...
</code></pre>
<p>Then physical devices:</p>
<pre><code>lrwxrwxrwx. 1 root root 0  6. Apr 09:21 sdzq -&gt; ../devices/pci0000:17/0000:17:00.0/0000:18:00.1/host18/rport-18:0-0/target18:0:0/18:0:0:28/block/sdzq
lrwxrwxrwx. 1 root root 0  6. Apr 09:21 sdzr -&gt; ../devices/pci0000:17/0000:17:00.0/0000:18:00.1/host18/rport-18:0-0/target18:0:0/18:0:0:29/block/sdzr
lrwxrwxrwx. 1 root root 0  6. Apr 09:21 sdzs -&gt; ../devices/pci0000:17/0000:17:00.0/0000:18:00.1/host18/rport-18:0-0/target18:0:0/18:0:0:30/block/sdzs
...
</code></pre>
<p>--&gt; 2653 "/devices/pci..." devices there.<br />
All scanned.</p>
<h4 id="jsmeix_commented_at_2021-04-07_1337"><img src="https://avatars.githubusercontent.com/u/1788608?u=925fc54e2ce01551392622446ece427f51e2f0ce&v=4" width="50"><a href="https://github.com/jsmeix">jsmeix</a> commented at <a href="https://github.com/rear/rear/pull/2597#issuecomment-814920754">2021-04-07 13:37</a>:<a class="headerlink" href="#jsmeix_commented_at_2021-04-07_1337" title="Permanent link">&para;</a></h4>
<p>@rmetrich<br />
does perhaps the<br />
<code>lsblk -ipo NAME,KNAME,PKNAME,TRAN,TYPE,FSTYPE,SIZE,MOUNTPOINT</code><br />
output indicate something how the actually interesting block devices<br />
could be distinguished from the non-interesting block devices?</p>
<p>What I have in mind is:</p>
<p>When looking at that code part in
layout/save/GNU/Linux/200_partition_layout.sh</p>
<pre><code>    for disk in /sys/block/* ; do
        blockd=${disk#/sys/block/}
        if [[ $blockd = hd* || $blockd = sd* || $blockd = cciss* || $blockd = vd* || $blockd = xvd* || $blockd = dasd* || $blockd = nvme* || $blockd = mmcblk* ]] ; then
...
            if is_multipath_path ${blockd} ; then
                Log "Ignoring $blockd: it is a path of a multipath device"
            elif [[ ! ($blockd = *rpmb || $blockd = *[0-9]boot[0-9]) ]]; then # Silently skip Replay Protected Memory Blocks and others  
                devname=$(get_device_name $disk)
                devsize=$(get_disk_size ${disk#/sys/block/})
                disktype=$(parted -s $devname print | grep -E "Partition Table|Disk label" | cut -d ":" -f "2" | tr -d " ")

                echo "# Disk $devname"
                echo "# Format: disk &lt;devname&gt; &lt;size(bytes)&gt; &lt;partition label type&gt;"
                echo "disk $devname $devsize $disktype"

                echo "# Partitions on $devname"
                echo "# Format: part &lt;device&gt; &lt;partition size(bytes)&gt; &lt;partition start(bytes)&gt; &lt;partition type|name&gt; &lt;flags&gt; /dev/&lt;partition&gt;"
                extract_partitions "$devname"
            fi
        fi
    done
</code></pre>
<p>the interesting block devices are those where<br />
commands like <code>parted -s $devname print</code> make sense<br />
i.e. the interesting block devices are what is commonly known<br />
as "real disks" with partitions on it.</p>
<p>I wonder if there isn't a more direct way to get the intended "real
disks"<br />
than to first list all block devices and then sort out the unintended
ones.</p>
<p>I know basically nothing about multipath so the following could be plain
wrong:<br />
I think the problem with multipath is that one "real disk behind
multipath" appears<br />
as several duplicates under normal <code>/dev/sd[a-z]*</code> disk device nodes.<br />
Because normal <code>/dev/sd[a-z]*</code> disk device nodes must be normally
considered<br />
it means for multipath that all those multipath duplicates must be also
considered<br />
and sorted out via <code>is_multipath_path ${blockd}</code> which costs time :-(</p>
<h4 id="jsmeix_commented_at_2021-04-07_1357"><img src="https://avatars.githubusercontent.com/u/1788608?u=925fc54e2ce01551392622446ece427f51e2f0ce&v=4" width="50"><a href="https://github.com/jsmeix">jsmeix</a> commented at <a href="https://github.com/rear/rear/pull/2597#issuecomment-814936492">2021-04-07 13:57</a>:<a class="headerlink" href="#jsmeix_commented_at_2021-04-07_1357" title="Permanent link">&para;</a></h4>
<p>@pcahyna<br />
perhaps in the function <code>is_multipath_path</code> in lib/layout-functions.sh<br />
the most time consuming part is not the device specific call</p>
<pre><code>multipath -c /dev/$1
</code></pre>
<p>but the listing of the whole multipath topology via</p>
<pre><code>multipath -l | grep -q '[[:alnum:]]' || return 1
</code></pre>
<p>see my comment in the code why I added that call<br />
<a href="https://github.com/rear/rear/blob/master/usr/share/rear/lib/layout-functions.sh#L718">https://github.com/rear/rear/blob/master/usr/share/rear/lib/layout-functions.sh#L718</a></p>
<h4 id="jsmeix_commented_at_2021-04-07_1402"><img src="https://avatars.githubusercontent.com/u/1788608?u=925fc54e2ce01551392622446ece427f51e2f0ce&v=4" width="50"><a href="https://github.com/jsmeix">jsmeix</a> commented at <a href="https://github.com/rear/rear/pull/2597#issuecomment-814940609">2021-04-07 14:02</a>:<a class="headerlink" href="#jsmeix_commented_at_2021-04-07_1402" title="Permanent link">&para;</a></h4>
<p>@rmetrich<br />
could you try out how long it runs when you only comment out the line</p>
<pre><code>multipath -l | grep -q '[[:alnum:]]' || return 1
</code></pre>
<p>in the function <code>is_multipath_path</code> in lib/layout-functions.sh ?</p>
<h4 id="rmetrich_commented_at_2021-04-07_1414"><img src="https://avatars.githubusercontent.com/u/1163635?u=36b5e32e1dd55f1ce77cad431a5683fce40a7934&v=4" width="50"><a href="https://github.com/rmetrich">rmetrich</a> commented at <a href="https://github.com/rear/rear/pull/2597#issuecomment-814950019">2021-04-07 14:14</a>:<a class="headerlink" href="#rmetrich_commented_at_2021-04-07_1414" title="Permanent link">&para;</a></h4>
<p>I cannot, it's a customer that has the issue, but I can print here the
log taken in Debug:</p>
<pre><code>2021-04-02 11:40:15.927764930 No partitions found on /dev/sdaht.
2021-04-02 11:40:17.589797772 No partitions found on /dev/sdaig.
2021-04-02 11:40:17.615676066 No partitions found on /dev/sdaih.
...
2021-04-02 11:47:34.067632684 No partitions found on /dev/sdzx.
2021-04-02 11:47:34.106361186 No partitions found on /dev/sdzy.
2021-04-02 11:47:34.139715422 No partitions found on /dev/sdzz.
</code></pre>
<p>then</p>
<pre><code>2021-04-02 11:49:19.249785504 Disk /dev/sdaa is not used by any mounted filesystem. Excluding.
2021-04-02 11:49:19.251896277 Marking /dev/sdaa as done.
2021-04-02 11:49:19.263201014 Marking opaldisk:/dev/sdaa as done.
2021-04-02 11:49:19.342139884 Marking /dev/sdaa1 as done (dependent on /dev/sdaa)
2021-04-02 11:49:19.344697017 Marking /dev/sdaa1 as done.
...

2021-04-02 11:53:10.810005723 Marking opaldisk:/dev/sdzy as done.
2021-04-02 11:53:10.844155949 Disk /dev/sdzz is not used by any mounted filesystem. Excluding.
2021-04-02 11:53:10.846765299 Marking /dev/sdzz as done.
2021-04-02 11:53:10.864604452 Marking opaldisk:/dev/sdzz as done.
</code></pre>
<p>So that's 10 minutes on that system (but the customer has larger
ones).<br />
Then there is Grub2 probe running for 20 minutes:</p>
<pre><code>2021-04-02 12:02:37.511409752 Including output/default/940_grub2_rescue.sh
2021-04-02 12:02:37.512429156 Entering debugscripts mode via 'set -x'.
2021-04-02 12:02:37.532636160 Setting up GRUB_RESCUE: Adding Relax-and-Recover rescue system to the local GRUB 2 configuration.
...
2021-04-02 12:23:50.177669407 Finished GRUB_RESCUE setup: Added 'Relax-and-Recover' GRUB 2 menu entry.
</code></pre>
<h4 id="jsmeix_commented_at_2021-04-07_1423"><img src="https://avatars.githubusercontent.com/u/1788608?u=925fc54e2ce01551392622446ece427f51e2f0ce&v=4" width="50"><a href="https://github.com/jsmeix">jsmeix</a> commented at <a href="https://github.com/rear/rear/pull/2597#issuecomment-814957059">2021-04-07 14:23</a>:<a class="headerlink" href="#jsmeix_commented_at_2021-04-07_1423" title="Permanent link">&para;</a></h4>
<p>@rmetrich<br />
the customer could run once</p>
<pre><code># time multipath -l 2&gt;&amp;1 | wc -l
</code></pre>
<p>(the <code>| wc -l</code> is there to suppress the actual output but get an idea
how much it is)<br />
so we could get an idea how long it takes when <code>multipath -l</code> is run
2653 times.</p>
<h4 id="pcahyna_commented_at_2021-04-07_1610"><img src="https://avatars.githubusercontent.com/u/26300485?u=9105d243bc9f7ade463a3e52e8dd13fa67837158&v=4" width="50"><a href="https://github.com/pcahyna">pcahyna</a> commented at <a href="https://github.com/rear/rear/pull/2597#issuecomment-815038677">2021-04-07 16:10</a>:<a class="headerlink" href="#pcahyna_commented_at_2021-04-07_1610" title="Permanent link">&para;</a></h4>
<blockquote>
<p>does perhaps the<br />
<code>lsblk -ipo NAME,KNAME,PKNAME,TRAN,TYPE,FSTYPE,SIZE,MOUNTPOINT</code><br />
output indicate something how the actually interesting block devices<br />
could be distinguished from the non-interesting block devices?</p>
</blockquote>
<p><code>lsblk --nodeps -o fstype /dev/sd...</code> shows <code>mpath_member</code> for multipath
paths. This information seems to be eventually obtained from udev.</p>
<p>I suspect that the <code>multipath -c</code> command actually does not look at the
kernel multipath device tables, but checks whether the device should be
a multipath path, instead of checking whether the device actually is a
multipath path. It is even hinted in the manual page ("-c Check if a
block device should be a path in a multipath device."). This could be
the reason both for this problem and for #2298.</p>
<h4 id="pcahyna_commented_at_2021-04-07_1644"><img src="https://avatars.githubusercontent.com/u/26300485?u=9105d243bc9f7ade463a3e52e8dd13fa67837158&v=4" width="50"><a href="https://github.com/pcahyna">pcahyna</a> commented at <a href="https://github.com/rear/rear/pull/2597#issuecomment-815062930">2021-04-07 16:44</a>:<a class="headerlink" href="#pcahyna_commented_at_2021-04-07_1644" title="Permanent link">&para;</a></h4>
<blockquote>
<p>@rmetrich<br />
the customer could run once</p>
<pre><code># time multipath -l 2&gt;&amp;1 | wc -l
</code></pre>
<p>(the <code>| wc -l</code> is there to suppress the actual output but get an idea
how much it is)<br />
so we could get an idea how long it takes when <code>multipath -l</code> is run
2653 times.</p>
</blockquote>
<p>I don't think <code>multipath -l</code> is the problem here - the customer is
probably using ReaR 2.4 from RHEL 8 which does not have this command yet
(#2299 was not yet merged).</p>
<h4 id="pcahyna_commented_at_2021-04-07_1654"><img src="https://avatars.githubusercontent.com/u/26300485?u=9105d243bc9f7ade463a3e52e8dd13fa67837158&v=4" width="50"><a href="https://github.com/pcahyna">pcahyna</a> commented at <a href="https://github.com/rear/rear/pull/2597#issuecomment-815069972">2021-04-07 16:54</a>:<a class="headerlink" href="#pcahyna_commented_at_2021-04-07_1654" title="Permanent link">&para;</a></h4>
<p>Actually... @rmetrich maybe the problem lies not in any slowness of
<code>multipath -c</code>, but in returning wrong information. Can you please check
whether <code>multipath -c</code> returns the correct information (return code 0)
for all those <code>/dev/sd*</code> devices? You would see messages like "Ignoring
$blockd: it is a path of a multipath device" in the log if paths are
detected correctly (even without a debug log).</p>
<h4 id="jsmeix_commented_at_2021-04-08_1349"><img src="https://avatars.githubusercontent.com/u/1788608?u=925fc54e2ce01551392622446ece427f51e2f0ce&v=4" width="50"><a href="https://github.com/jsmeix">jsmeix</a> commented at <a href="https://github.com/rear/rear/pull/2597#issuecomment-815840720">2021-04-08 13:49</a>:<a class="headerlink" href="#jsmeix_commented_at_2021-04-08_1349" title="Permanent link">&para;</a></h4>
<p>@rmetrich @pcahyna<br />
I have a gereral understanding question:</p>
<p>I do not understand what the reason behind is why a system<br />
needs to have very many disk-like devices accessible.</p>
<p>Because<br />
<a href="https://documentation.suse.com/sles/15-SP2/html/SLES-all/cha-multipath.html#sec-multipath-mpiotools">https://documentation.suse.com/sles/15-SP2/html/SLES-all/cha-multipath.html#sec-multipath-mpiotools</a><br />
reads (excerpt)</p>
<pre><code>17.4.1 Device Mapper Multipath Module
...
Configurations of up to eight paths to each device are supported.
</code></pre>
<p>it seems eight paths to a device is a reasonable maximum<br />
that is used "out there in practice".</p>
<p>So when according to<br />
<a href="https://github.com/rear/rear/pull/2597#issuecomment-814908043">https://github.com/rear/rear/pull/2597#issuecomment-814908043</a><br />
there are 2653 <code>sd[a-z]*</code> device paths it seems<br />
there are 379 <code>dm-[0-9]*</code> multipath devices<br />
(because 7 is the only proper divisor &lt;= 8 i.e. <code>2653 = 379 * 7</code>)<br />
or there is one normal system disk /dev/sda (non-multipath)<br />
so there are 2652 <code>sd[a-z]*</code> multipath device paths with<br />
either 1326 = 2652 / 2 <code>dm-[0-9]*</code> multipath devices<br />
or 663 = 2652 / 4 <code>dm-[0-9]*</code> multipath devices<br />
or 442 = 2652 / 6 <code>dm-[0-9]*</code> multipath devices.</p>
<p>Or do I misunderstand something here?<br />
If not:<br />
I wonder why there are hundreds of multipath devices accessible on a
system.</p>
<p>Are those hundreds of disk-like devices perhaps<br />
first combined into RAID arrays to get RAID devices<br />
that are then perhaps used as LVM PVs to be<br />
further combined into VGs and LVs so that<br />
from hundreds of low level disk-like storage objects<br />
only a few high level strorage objects get created<br />
that are finally mounted?</p>
<p>Or is there perhaps some lower level configuration mistake<br />
(e.g. related to the SAN setup, perhaps no or insufficient SAN
zoning?)<br />
when a system has hundreds of disk-like devices accessible<br />
but most of them are perhaps not meant to be used by that system?</p>
<p>The</p>
<pre><code>lsblk -ipo NAME,KNAME,PKNAME,TRAN,TYPE,FSTYPE,SIZE,MOUNTPOINT
</code></pre>
<p>output of such a system could really help to better understand its
storage structure.</p>
<h4 id="rmetrich_commented_at_2021-04-08_1453"><img src="https://avatars.githubusercontent.com/u/1163635?u=36b5e32e1dd55f1ce77cad431a5683fce40a7934&v=4" width="50"><a href="https://github.com/rmetrich">rmetrich</a> commented at <a href="https://github.com/rear/rear/pull/2597#issuecomment-815889922">2021-04-08 14:53</a>:<a class="headerlink" href="#rmetrich_commented_at_2021-04-08_1453" title="Permanent link">&para;</a></h4>
<p>It's not rare that Red Hat customers have such many multipath devices on
their system.<br />
Usually they host large databases and stuff like that.<br />
So yes, here there is a single disk for the OS and the rest are "raw
devices" we shouldn't even look at.<br />
You can have similar devices with VxVM for example.</p>
<h4 id="jsmeix_commented_at_2021-04-09_0817"><img src="https://avatars.githubusercontent.com/u/1788608?u=925fc54e2ce01551392622446ece427f51e2f0ce&v=4" width="50"><a href="https://github.com/jsmeix">jsmeix</a> commented at <a href="https://github.com/rear/rear/pull/2597#issuecomment-816507796">2021-04-09 08:17</a>:<a class="headerlink" href="#jsmeix_commented_at_2021-04-09_0817" title="Permanent link">&para;</a></h4>
<p>@rmetrich<br />
thank you for the info how that system looks like.<br />
That helped.<br />
Now I understand.</p>
<pre><code>they host large databases and stuff like that
...
there is a single disk for the OS and
the rest are "raw devices" we shouldn't even look at
</code></pre>
<p>This is a special case.<br />
Even if that use case is relatively normal in enterprise server
environments<br />
usually each particular enterprise environment is an individual special
case.<br />
Special cases need special setup which needs special config variables<br />
to also provide "final power to special enterprise server admins"<br />
who are experienced users who know how to set special config variables<br />
properly to make things work as they need in their enterprise
environments.</p>
<p>Cf. the meaning behind of the "Dirty hacks welcome" section in<br />
<a href="https://github.com/rear/rear/wiki/Coding-Style">https://github.com/rear/rear/wiki/Coding-Style</a></p>
<p>So I agree with a new ONLY_INCLUDE_DISKS config variable.</p>
<h4 id="jsmeix_commented_at_2021-04-09_0838"><img src="https://avatars.githubusercontent.com/u/1788608?u=925fc54e2ce01551392622446ece427f51e2f0ce&v=4" width="50"><a href="https://github.com/jsmeix">jsmeix</a> commented at <a href="https://github.com/rear/rear/pull/2597#issuecomment-816522571">2021-04-09 08:38</a>:<a class="headerlink" href="#jsmeix_commented_at_2021-04-09_0838" title="Permanent link">&para;</a></h4>
<p>I am wondering if we should use<br />
in default.conf</p>
<pre><code>ONLY_INCLUDE_DISKS=()
</code></pre>
<p>and in layout/save/GNU/Linux/200_partition_layout.sh</p>
<pre><code>for disk in ${ONLY_INCLUDE_DISKS[@]:-/sys/block/*} ; do
</code></pre>
<p>OR<br />
if we should perhps better use<br />
in default.conf</p>
<pre><code>CONSIDER_DISKS=( /sys/block/* )
</code></pre>
<p>and in layout/save/GNU/Linux/200_partition_layout.sh</p>
<pre><code>for disk in ${CONSIDER_DISKS[@]} ; do
</code></pre>
<p>which looks simpler and more straightforward to me i.e. more KISS and<br />
less RFC 1925 item 6a "It is always possible to add another level of
indirection".</p>
<p>Now I see that the config variable name ONLY_INCLUDE_DISKS is wrong.<br />
It should be ONLY_CONSIDER_DISKS (or something else that tells its
actual meaning)<br />
because what is specified in that array is not what will be (only)
included<br />
because certain disks will get automatically excluded by the hardcoded<br />
conditions in layout/save/GNU/Linux/200_partition_layout.sh</p>
<h4 id="pcahyna_commented_at_2021-04-09_0840"><img src="https://avatars.githubusercontent.com/u/26300485?u=9105d243bc9f7ade463a3e52e8dd13fa67837158&v=4" width="50"><a href="https://github.com/pcahyna">pcahyna</a> commented at <a href="https://github.com/rear/rear/pull/2597#issuecomment-816523508">2021-04-09 08:40</a>:<a class="headerlink" href="#pcahyna_commented_at_2021-04-09_0840" title="Permanent link">&para;</a></h4>
<blockquote>
<p>@rmetrich<br />
thank you for the info how that system looks like.<br />
That helped.<br />
Now I understand.</p>
<pre><code>they host large databases and stuff like that
...
there is a single disk for the OS and
the rest are "raw devices" we shouldn't even look at
</code></pre>
<p>This is a special case.<br />
Even if that use case is relatively normal in enterprise server
environments<br />
usually each particular enterprise environment is an individual
special case.<br />
Special cases need special setup which needs special config
variables<br />
to also provide "final power to special enterprise server admins"<br />
who are experienced users who know how to set special config
variables<br />
properly to make things work as they need in their enterprise
environments.</p>
<p>Cf. the meaning behind of the "Dirty hacks welcome" section in<br />
<a href="https://github.com/rear/rear/wiki/Coding-Style">https://github.com/rear/rear/wiki/Coding-Style</a></p>
<p>So I agree with a new ONLY_INCLUDE_DISKS config variable.</p>
</blockquote>
<p>I will note that this special case should be already adequately covered
by the current code that skips multipath paths, so I would like to
determine why it does not work as expected first. Otherwise you may just
introduce a dirty hack which does not in fact allow some new special
case, but is merely a workaround for another part of the code not
working properly.</p>
<h4 id="jsmeix_commented_at_2021-04-09_0850"><img src="https://avatars.githubusercontent.com/u/1788608?u=925fc54e2ce01551392622446ece427f51e2f0ce&v=4" width="50"><a href="https://github.com/jsmeix">jsmeix</a> commented at <a href="https://github.com/rear/rear/pull/2597#issuecomment-816529397">2021-04-09 08:50</a>:<a class="headerlink" href="#jsmeix_commented_at_2021-04-09_0850" title="Permanent link">&para;</a></h4>
<p>@pcahyna<br />
I agree that we need to find out why it is so slow for thousands of<br />
multipath path devices in <code>/sys/block/*</code></p>
<p>Perhaps we find out that we cannot get automated exclusion of<br />
thousands of multipath path devices sufficiently fast,<br />
cf.
<a href="https://github.com/rear/rear/pull/2597#issuecomment-814950019">https://github.com/rear/rear/pull/2597#issuecomment-814950019</a><br />
"there is Grub2 probe running for 20 minutes"<br />
(we could not make Grub2 probe running faster).</p>
<p>My general intent is to provide "final power to all users"<br />
what layout components get included and what get excluded.</p>
<p>Perhaps my above <code>CONSIDER_DISKS=( /sys/block/* )</code> proposal<br />
points into the right direction.</p>
<p>Perhaps we could have <code>INCLUDE_DISKS=()</code> so the current default<br />
to consider all in <code>/sys/block/*</code> and automatically exclude by the
hardcoded<br />
conditions in layout/save/GNU/Linux/200_partition_layout.sh is done<br />
while a user specified <code>INCLUDE_DISKS=( sda sdc )</code> will include (only)
them<br />
and skip all exclude conditions in
layout/save/GNU/Linux/200_partition_layout.sh</p>
<h4 id="pcahyna_commented_at_2021-04-09_0900"><img src="https://avatars.githubusercontent.com/u/26300485?u=9105d243bc9f7ade463a3e52e8dd13fa67837158&v=4" width="50"><a href="https://github.com/pcahyna">pcahyna</a> commented at <a href="https://github.com/rear/rear/pull/2597#issuecomment-816535485">2021-04-09 09:00</a>:<a class="headerlink" href="#pcahyna_commented_at_2021-04-09_0900" title="Permanent link">&para;</a></h4>
<blockquote>
<p>Perhaps we find out that we cannot get automated exclusion of<br />
thousands of multipath path devices sufficiently fast.</p>
</blockquote>
<p>Perhaps. And perhaps not. It would be good to know whether there is
really such a fundamental problem before attempting to "solve" it using
yet another configuration variable.</p>
<blockquote>
<p>My general intent is to provide "final power to all users"<br />
what layout components get included and what get excluded.</p>
</blockquote>
<p>I am afraid that in this case you would provide merely the power to all
users to shoot themselves in the foot without providing the
complementary power of aiming properly. Aren't the SCSI device names
allocated in an essentially unpredictable order? Is then wise to use
them as stable identifiers in a config file? I think it is much more
preferable to let the users describe includes and excludes in terms of
some stable identifiers (like filesystem mount points, volume groups or
logical volumes).</p>
<p>Also, the discussion here is not about what to exclude (multipath
components are excluded anyway), but about a performance optimization
which allows to avoid looking at them before excluding them.<br />
EDIT: This is not entirely correct, the proposed change introduces
indeed a new way to define what is included/excluded, but the primary
motivation was an optimization and not having another way of configuring
inclusion/exclusion.</p>
<h4 id="pcahyna_commented_at_2021-04-09_1025"><img src="https://avatars.githubusercontent.com/u/26300485?u=9105d243bc9f7ade463a3e52e8dd13fa67837158&v=4" width="50"><a href="https://github.com/pcahyna">pcahyna</a> commented at <a href="https://github.com/rear/rear/pull/2597#issuecomment-816585654">2021-04-09 10:25</a>:<a class="headerlink" href="#pcahyna_commented_at_2021-04-09_1025" title="Permanent link">&para;</a></h4>
<p>@rmetrich</p>
<blockquote>
<p>So yes, here there is a single disk for the OS and the rest are "raw
devices" we shouldn't even look at.</p>
</blockquote>
<p>I understand that it would be desirable to have a generic way to tell
what devices to avoid looking at. Even if we manage to fix it for the
multipath case, what if a customer uses non-multipath devices for such
purposes? Given the problems with configuring this kind of exclusion
using explicit device names, would it be possible to ask the kernel
whether there is anything interesting on the drives? After all, the
kernel looks at disks when they are configured to search for partition
tables etc. Would it work to automatically exclude disks that have no
partitions known to the kernel, no mounted filesystems and no holders
(<code>/sys/block/*/holders</code>)?</p>
<h4 id="pcahyna_commented_at_2021-04-09_1028"><img src="https://avatars.githubusercontent.com/u/26300485?u=9105d243bc9f7ade463a3e52e8dd13fa67837158&v=4" width="50"><a href="https://github.com/pcahyna">pcahyna</a> commented at <a href="https://github.com/rear/rear/pull/2597#issuecomment-816587171">2021-04-09 10:28</a>:<a class="headerlink" href="#pcahyna_commented_at_2021-04-09_1028" title="Permanent link">&para;</a></h4>
<p>FYI multipath component devices have a <code>/sys/block/*/holders/*</code> symlink
that points to the multipath device, so it is possible to recognize them
this way (if one does not want to use <code>lsblk</code>).</p>
<h4 id="jsmeix_commented_at_2021-04-09_1120"><img src="https://avatars.githubusercontent.com/u/1788608?u=925fc54e2ce01551392622446ece427f51e2f0ce&v=4" width="50"><a href="https://github.com/jsmeix">jsmeix</a> commented at <a href="https://github.com/rear/rear/pull/2597#issuecomment-816613184">2021-04-09 11:20</a>:<a class="headerlink" href="#jsmeix_commented_at_2021-04-09_1120" title="Permanent link">&para;</a></h4>
<p>@pcahyna<br />
perhaps I misunderstand what you wrote</p>
<pre><code>I am afraid that in this case you would provide merely the
power to all users to shoot themselves in the foot
without providing the complementary power of aiming properly
</code></pre>
<p>but for me <code>provide final power to all users</code> essentially means<br />
to provide the power to all users to even shoot themselves in the foot.</p>
<p>ReaR is meant to be used by a user who is <code>root</code> and such users<br />
have unlimited power to do what they want on their systems<br />
where "aiming properly" is completely their own responsibility<br />
just as it is for a real shooter - the gun provides him power<br />
but "aiming properly" is completely the shooter's responsibility.</p>
<p>In contrast to a weapon ReaR has reasonably safe default behaviour<br />
(at least for the commonly known and well tested use cases).</p>
<p>By default ReaR should avoid (as far as possible with reasonable
effort)<br />
that a ReaR user shoots himself in the foot (but there are still many
places<br />
where ReaR does not protect the user to shoot himself in the foot).</p>
<p>The crucial part - and that is what I have to basically always explain -
is<br />
that for me "provide final power to all users" means</p>
<ul>
<li>first and foremost a reasonable default behaviour</li>
</ul>
<p>plus</p>
<ul>
<li>the user has unlimited power to change the defaults as he likes</li>
</ul>
<p>When the user changed something then things could fail in arbitrary
ways.<br />
Of course we would try to error out cleanly when user settings cannot
work,<br />
cf. "Try hard to care about possible errors" in<br />
<a href="https://github.com/rear/rear/wiki/Coding-Style">https://github.com/rear/rear/wiki/Coding-Style</a><br />
but we cannot ensure that we catch all bad cases so things might even
go<br />
terribly wrong when the user changed something in unexpected ways.</p>
<p>Simply put:<br />
In "final power to the user" the word 'final' is crucial<br />
so "final power to the user" does not mean the program does nothing to
avoid bad outcome<br />
instead it means the program does not hinder the user to explicitly let
it also do bad things.</p>
<p>Or in other words:<br />
"Final power to the user" means<br />
the programmer gives his power away to the user of his program<br />
and not the programmer keeps the power himself via hardcoded things in
his program.</p>
<p>The perfect example for "final power to the user" is nowadays "# rm -rf
/":</p>
<pre><code># rm -rf /
rm: it is dangerous to operate recursively on '/'
rm: use --no-preserve-root to override this failsafe

# rm -rf --no-presreve-root /
[all is gone now]
</code></pre>
<h4 id="jsmeix_commented_at_2021-04-09_1131"><img src="https://avatars.githubusercontent.com/u/1788608?u=925fc54e2ce01551392622446ece427f51e2f0ce&v=4" width="50"><a href="https://github.com/jsmeix">jsmeix</a> commented at <a href="https://github.com/rear/rear/pull/2597#issuecomment-816618349">2021-04-09 11:31</a>:<a class="headerlink" href="#jsmeix_commented_at_2021-04-09_1131" title="Permanent link">&para;</a></h4>
<p>Regarding</p>
<pre><code>what if a customer uses non-multipath devices for such purposes
...
the proposed change introduces indeed a new way to define what is included/excluded,
but the primary motivation was an optimization
</code></pre>
<p>Exactly.</p>
<p>My proposed change introduces intentionally a generic way<br />
to define what disks are included (and all others are excluded)<br />
because I like to avoid optimization "hacks" for specific cases.</p>
<p>I think my proposed change would also help a user who has<br />
a few disks for the OS (the only ones of interest for ReaR) and<br />
hundreds of (non-multipath) "raw devices" to host large databases.</p>
<p>I think @rmetrich current ONLY_INCLUDE_DISKS implementation<br />
would do the same - only the variable name is misleading as long as<br />
the exclude conditions in
layout/save/GNU/Linux/200_partition_layout.sh<br />
are not skipped when ONLY_INCLUDE_DISKS is specified.</p>
<h4 id="pcahyna_commented_at_2021-04-09_1210"><img src="https://avatars.githubusercontent.com/u/26300485?u=9105d243bc9f7ade463a3e52e8dd13fa67837158&v=4" width="50"><a href="https://github.com/pcahyna">pcahyna</a> commented at <a href="https://github.com/rear/rear/pull/2597#issuecomment-816638035">2021-04-09 12:10</a>:<a class="headerlink" href="#pcahyna_commented_at_2021-04-09_1210" title="Permanent link">&para;</a></h4>
<p>@jsmeix</p>
<blockquote>
<p>perhaps I misunderstand what you wrote</p>
<pre><code>I am afraid that in this case you would provide merely the
power to all users to shoot themselves in the foot
without providing the complementary power of aiming properly
</code></pre>
<p>but for me <code>provide final power to all users</code> essentially means<br />
to provide the power to all users to even shoot themselves in the
foot.</p>
<p>ReaR is meant to be used by a user who is <code>root</code> and such users<br />
have unlimited power to do what they want on their systems<br />
where "aiming properly" is completely their own responsibility<br />
just as it is for a real shooter - the gun provides him power<br />
but "aiming properly" is completely the shooter's responsibility.</p>
</blockquote>
<p>I think you indeed misunderstood. My point was that you make the user
responsible for "aiming properly", but in this case you would not
provide them with proper means for aiming. The only way the proposed
variable aims at block devices is by using their assigned names, which
are, I am afraid, not reliable - <code>/sys/block/sdxyz</code> can become
<code>/sys/block/sdqux</code> on next boot. (IIRC I even saw an issue about similar
problems from you, but I can't find it now.) So a user might determine
that including <code>/sys/block/sdxyz</code> works for them, but after a reboot it
becomes <code>/sys/dev/sdqux</code> and gets excluded from the backup.</p>
<p>Moreover, generally speaking, while places where "users can shoot
themselves in the foot" are acceptable in a tool like this, I believe
one should be cautious when adding a new one and first ask whether the
same desired outcome can be achieved in a safer way.</p>
<h4 id="jsmeix_commented_at_2021-04-09_1210"><img src="https://avatars.githubusercontent.com/u/1788608?u=925fc54e2ce01551392622446ece427f51e2f0ce&v=4" width="50"><a href="https://github.com/jsmeix">jsmeix</a> commented at <a href="https://github.com/rear/rear/pull/2597#issuecomment-816638052">2021-04-09 12:10</a>:<a class="headerlink" href="#jsmeix_commented_at_2021-04-09_1210" title="Permanent link">&para;</a></h4>
<p>Regarding</p>
<pre><code>Aren't the SCSI device names allocated in an essentially unpredictable order?
Is then wise to use them as stable identifiers in a config file?
</code></pre>
<p>Yes, cf.
<a href="https://github.com/rear/rear/issues/2254">https://github.com/rear/rear/issues/2254</a></p>
<p>But layout/save/GNU/Linux/200_partition_layout.sh<br />
is run on the original system when it is up and running<br />
and ReaR config files are executed <code>source</code>d as scripts, cf.<br />
<a href="https://github.com/rear/rear/blob/master/etc/rear/local.conf">https://github.com/rear/rear/blob/master/etc/rear/local.conf</a></p>
<p>So the user could implement what is needed in his special case to
specify<br />
the currently right kernel device names while "rear mkrescue/mkbackup"
is<br />
running i.e. while layout/save/GNU/Linux/200_partition_layout.sh is
running.</p>
<p>Those kernel device names at the time when "rear mkrescue/mkbackup"<br />
is running get stored in disklayout.conf.</p>
<p>When on the replacement hardware other kernel device names are used<br />
ReaR should normally go automatically into MIGRATION_MODE<br />
(cf. its description in default.conf).<br />
In MIGRATION_MODE the user must during "rear recover"<br />
manually specify the right device name mapping<br />
(via some simple user dialog).</p>
<p>This is a nice example where current ReaR<br />
does not protect the user to shoot himself in the foot.<br />
When he accepts a wrong device mapping<br />
ReaR will "just install" on a wrong device, cf.<br />
<a href="https://github.com/rear/rear/issues/1271">https://github.com/rear/rear/issues/1271</a></p>
<h4 id="pcahyna_commented_at_2021-04-09_1224"><img src="https://avatars.githubusercontent.com/u/26300485?u=9105d243bc9f7ade463a3e52e8dd13fa67837158&v=4" width="50"><a href="https://github.com/pcahyna">pcahyna</a> commented at <a href="https://github.com/rear/rear/pull/2597#issuecomment-816645289">2021-04-09 12:24</a>:<a class="headerlink" href="#pcahyna_commented_at_2021-04-09_1224" title="Permanent link">&para;</a></h4>
<blockquote>
<p>Regarding</p>
<pre><code>Aren't the SCSI device names allocated in an essentially unpredictable order?
Is then wise to use them as stable identifiers in a config file?
</code></pre>
<p>Yes, cf. #2254</p>
</blockquote>
<p>That's what I meant, thanks.</p>
<blockquote>
<p>But layout/save/GNU/Linux/200_partition_layout.sh<br />
is run on the original system when it is up and running<br />
and ReaR config files are executed <code>source</code>d as scripts, cf.<br />
<a href="https://github.com/rear/rear/blob/master/etc/rear/local.conf">https://github.com/rear/rear/blob/master/etc/rear/local.conf</a></p>
<p>So the user could implement what is needed in his special case to
specify<br />
the currently right kernel device names while "rear mkrescue/mkbackup"
is<br />
running i.e. while layout/save/GNU/Linux/200_partition_layout.sh is
running.</p>
</blockquote>
<p>For the case that motivated this PR, the problem is, how will the user
implement this detection (of unwanted multipath devices)? Either they
implement it in the same way as it is done now in ReaR, but then they
will save nothing, because if the method is the same, it will lead to
the same 40-minute delay.<br />
Or they implement something better, but then why not implement this
"better thing" in ReaR directly?<br />
You mentioned that "perhaps we find out that we cannot get automated
exclusion of thousands of multipath path devices sufficiently fast".
This is certainly a possibility, but in this case the power given to the
user is illusory. It will not allow them to make any actual improvement
in their local configuration, lest they hardcode the list of device
names in the config file and be surprised when the devices rename on
some future reboot.</p>
<p>Of course, I know that you want to make the variable more generic and
not tied to this specific case, which certainly goes in the right
direction and the argument above does not apply. But...</p>
<blockquote>
<p>Those kernel device names at the time when "rear mkrescue/mkbackup"<br />
is running get stored in disklayout.conf.</p>
<p>When on the replacement hardware other kernel device names are used<br />
ReaR should normally go automatically into MIGRATION_MODE<br />
(cf. its description in default.conf).<br />
In MIGRATION_MODE the user must during "rear recover"<br />
manually specify the right device name mapping<br />
(via some simple user dialog).</p>
<p>This is a nice example where current ReaR<br />
does not protect the user to shoot himself in the foot.<br />
When he accepts a wrong device mapping<br />
ReaR will "just install" on a wrong device, cf.<br />
#1271</p>
</blockquote>
<p>I am sure that relying on (unpredictable) device names is already a
problem in the current code. I am only saying that it would be better to
avoid introducing another place which relies on them and thus amplifying
the problem. Especially among configuration variables, as those are the
documented user interface that one should not change (because of
compatibility).</p>
<h4 id="jsmeix_commented_at_2021-04-09_1224"><img src="https://avatars.githubusercontent.com/u/1788608?u=925fc54e2ce01551392622446ece427f51e2f0ce&v=4" width="50"><a href="https://github.com/jsmeix">jsmeix</a> commented at <a href="https://github.com/rear/rear/pull/2597#issuecomment-816645309">2021-04-09 12:24</a>:<a class="headerlink" href="#jsmeix_commented_at_2021-04-09_1224" title="Permanent link">&para;</a></h4>
<p>@pcahyna<br />
yes of course we should be cautious and careful with what we
implement.<br />
I found too many places where the "code blindly proceed in case of
errors"<br />
cf. "Try hard to care about possible errors" in
<a href="https://github.com/rear/rear/wiki/Coding-Style">https://github.com/rear/rear/wiki/Coding-Style</a><br />
and I know there are still many such places left that would need to be
fixed...</p>
<p>I appreciate your research to find a more reliably (and hopefully
faster)<br />
working method to detect when a block device is a multipath path
device.<br />
The current <code>is_multipath_path</code> function implementation had hit us too
often<br />
so a better method would help so much.<br />
This task belongs to the above mentioned</p>
<ul>
<li>first and foremost a reasonable default behaviour</li>
</ul>
<p>My long term intent to introduce a generic way<br />
to let the user define what disks are included<br />
is a separated task that was triggered by this issue here.<br />
This task belongs to the above mentioned</p>
<ul>
<li>the user has unlimited power to change the defaults as he likes</li>
</ul>
<p>The "first and foremost" makes clear what should be done first and
foremost ;-)</p>
<h4 id="jsmeix_commented_at_2021-04-09_1234"><img src="https://avatars.githubusercontent.com/u/1788608?u=925fc54e2ce01551392622446ece427f51e2f0ce&v=4" width="50"><a href="https://github.com/jsmeix">jsmeix</a> commented at <a href="https://github.com/rear/rear/pull/2597#issuecomment-816650462">2021-04-09 12:34</a>:<a class="headerlink" href="#jsmeix_commented_at_2021-04-09_1234" title="Permanent link">&para;</a></h4>
<p>@pcahyna<br />
very interesting conclusion in your<br />
<a href="https://github.com/rear/rear/pull/2597#issuecomment-816645289">https://github.com/rear/rear/pull/2597#issuecomment-816645289</a></p>
<pre><code>how will the user implement this detection (of unwanted multipath devices)?
Either they implement it in the same way as it is done now in ReaR,
but then they will save nothing...
Or they implement something better, but then why not implement
this "better thing" in ReaR directly?
</code></pre>
<p>You are right.</p>
<h4 id="jsmeix_commented_at_2021-04-09_1256"><img src="https://avatars.githubusercontent.com/u/1788608?u=925fc54e2ce01551392622446ece427f51e2f0ce&v=4" width="50"><a href="https://github.com/jsmeix">jsmeix</a> commented at <a href="https://github.com/rear/rear/pull/2597#issuecomment-816662237">2021-04-09 12:56</a>:<a class="headerlink" href="#jsmeix_commented_at_2021-04-09_1256" title="Permanent link">&para;</a></h4>
<p>@pcahyna<br />
but isn't it the point of @rmetrich pull request here<br />
that with a new config variable to specify the wanted disks<br />
there is no need for detection of unwanted disks<br />
so any detection issues can be avoided?</p>
<p>With a new config variable to specify the wanted disks<br />
the user only needs to detect the wanted disks<br />
where it does not matter when it is slow for only a few wanted disks<br />
and he does not need to detect any unwanted disks<br />
which could delay things when it is slow for very many unwanted disks.</p>
<p>So when we cannot implement right now or perhaps never<br />
a reliable and sufficiently fast default behaviour<br />
then<br />
a generic "final power to the user" method would help the user.</p>
<p>Both parts<br />
<code>first and foremost a reasonable default behaviour</code><br />
and<br />
<code>the user has unlimited power to change the defaults as he likes</code><br />
do not contradict or compete but complement each other<br />
and both help the user in the end.</p>
<h4 id="jsmeix_commented_at_2021-04-09_1302"><img src="https://avatars.githubusercontent.com/u/1788608?u=925fc54e2ce01551392622446ece427f51e2f0ce&v=4" width="50"><a href="https://github.com/jsmeix">jsmeix</a> commented at <a href="https://github.com/rear/rear/pull/2597#issuecomment-816665563">2021-04-09 13:02</a>:<a class="headerlink" href="#jsmeix_commented_at_2021-04-09_1302" title="Permanent link">&para;</a></h4>
<p>Sun is shining, weekend is there, and<br />
I wish you all a relaxed and recovering weekend!</p>
<h4 id="pcahyna_commented_at_2021-04-09_1311"><img src="https://avatars.githubusercontent.com/u/26300485?u=9105d243bc9f7ade463a3e52e8dd13fa67837158&v=4" width="50"><a href="https://github.com/pcahyna">pcahyna</a> commented at <a href="https://github.com/rear/rear/pull/2597#issuecomment-816671377">2021-04-09 13:11</a>:<a class="headerlink" href="#pcahyna_commented_at_2021-04-09_1311" title="Permanent link">&para;</a></h4>
<p>@jsmeix</p>
<blockquote>
<p>but isn't it the point of @rmetrich pull request here<br />
that with a new config variable to specify the wanted disks<br />
there is no need for detection of unwanted disks<br />
so any detection issues can be avoided?</p>
<p>With a new config variable to specify the wanted disks<br />
the user only needs to detect the wanted disks<br />
where it does not matter when it is slow for only a few wanted disks<br />
and he does not need to detect any unwanted disks<br />
which could delay things when it is slow for very many unwanted disks.</p>
</blockquote>
<p>Depends. The question is, is it possible to implement a reliable way of
detecting the wanted disks without looking at all the disks and
examining whether they are wanted or not? It seems that in this case the
condition is "the disk is wanted if it is not multipath". In this case
one has to look at all the disks to determine whether they are multipath
and my reasoning applies. But perhaps there would be a better way. (I
would say that one possible better way would be to start at the objects
that the user is interested in - esp. filesystems, maybe LVs, VGs,
RAIDs, and recursively determine their underlying devices until one
reaches the leaves, instead of starting from the leaves and building the
entire stack from the bottom up.) Still, this better way could then be
worth implementing in ReaR in a generic manner, but perhaps it is too
difficult.</p>
<h4 id="jsmeix_commented_at_2021-04-19_1105"><img src="https://avatars.githubusercontent.com/u/1788608?u=925fc54e2ce01551392622446ece427f51e2f0ce&v=4" width="50"><a href="https://github.com/jsmeix">jsmeix</a> commented at <a href="https://github.com/rear/rear/pull/2597#issuecomment-822382884">2021-04-19 11:05</a>:<a class="headerlink" href="#jsmeix_commented_at_2021-04-19_1105" title="Permanent link">&para;</a></h4>
<p>@pcahyna<br />
regarding your
<a href="https://github.com/rear/rear/pull/2597#issuecomment-816671377">https://github.com/rear/rear/pull/2597#issuecomment-816671377</a></p>
<p>The commonly used point of view is that in the tree-like structure of
storage objects<br />
(it is no tree because one higher level storage object could have more
than one parent<br />
e.g. a non-degraded software RAID array "md" device has at least two
parent devices)<br />
the actual disks are the root devices and on them certain levels of
higher and higher<br />
level storage objects are built until the leaves are usually some
"mountable thingies"<br />
(like filesystems or btrfs subvolumes).</p>
<p>This commonly used point of view is what <code>lsblk</code> shows<br />
and what admins usually have in mind when they imagine<br />
their particular tree-like structure of storage objects on their
machines.</p>
<p>Cf. what Stefan Hundhammer wrote in<br />
<a href="https://lists.opensuse.org/archives/list/yast-devel@lists.opensuse.org/thread/YK6MJ4WYT5TS672FMOKK2BNULCNLFIE6/">https://lists.opensuse.org/archives/list/yast-devel@lists.opensuse.org/thread/YK6MJ4WYT5TS672FMOKK2BNULCNLFIE6/</a><br />
(excerpt):</p>
<pre><code>Users know they have disks in their computers; so we should represent 
them, visualize them. This is the primary handle for users because it 
corresponds to something from the real world; something they can touch, 
something they can buy in a shop. You can't buy a partition or an LVM, 
but you CAN buy a disk. Don't take away from users the few things from 
the real world that they can make sense of in this context. ;-)
</code></pre>
<p>Same appies for virtual disks.<br />
Virtual disks are what admins have first and foremost on virtual
machines.</p>
<p>So in ReaR we also should let the user specify his things<br />
according to how he is used to imagine his things,<br />
i.e. first and foremost disks.</p>
<p>So far from a usability point of view.</p>
<p>Now from a "what ReaR is meant to do" point of view:</p>
<p>ReaR's main task is to recreate a system as much as possible as it was
before<br />
on bare metal replacement hardware (or on bare virtual machines).</p>
<p>It is not ReaR's main task to initially create a system where it might
make sense<br />
to let the user specify the final storage objects (usually "mountable
thingies")<br />
and let some (semi)-automatism create the needed lower and lower level<br />
storage objects until finally some disks are used (those where the
intended<br />
final storage objects fit best).</p>
<p>It is ReaR's main task is to use "same" disks as on the original
system<br />
and recreate on them the same structure of higher and higher<br />
level storage objects.</p>
<p>Finally from a technical point of view:</p>
<p>To create a structure of storage objects on bare metal replacement
hardware<br />
(or on a bare virtual machine) one must start with disks, create
partitions on them,<br />
and so on.</p>
<p>Therefore ReaR uses "whole" disks when recreating<br />
and its first thing is <code>parted mklabel</code>, then <code>parted mkpart</code> and so on.</p>
<p>There is no code in ReaR to "partially" recreate storage objects on a
disk.</p>
<p>Summary (from my point of view):</p>
<p>It would help the user a lot if he could specify with final power<br />
what disks ReaR has to use (and then all other disks must not be used).</p>
<p>When a higher level storage object (e.g. a LV in a VG that is spread
over several disks)<br />
uses a disk that is not specified to be used (if the user has specified
what to use)<br />
ReaR (i.e. "rear mkrescue") must error out so the user would see the
conflict.</p>
<h4 id="jsmeix_commented_at_2021-04-19_1141"><img src="https://avatars.githubusercontent.com/u/1788608?u=925fc54e2ce01551392622446ece427f51e2f0ce&v=4" width="50"><a href="https://github.com/jsmeix">jsmeix</a> commented at <a href="https://github.com/rear/rear/pull/2597#issuecomment-822401367">2021-04-19 11:41</a>:<a class="headerlink" href="#jsmeix_commented_at_2021-04-19_1141" title="Permanent link">&para;</a></h4>
<p>@rmetrich<br />
I do not want to work against you and/or what you intend here<br />
so I would like to know it it would be OK for you when I implement<br />
some generic <code>INCLUDE_DISKS</code> functionality as I described in<br />
<a href="https://github.com/rear/rear/pull/2597#issuecomment-816529397">https://github.com/rear/rear/pull/2597#issuecomment-816529397</a><br />
and subsequent comments or if you disagree with me?</p>
<p>@rear/contributors<br />
I could do an initial separated pull request so you could have a look<br />
and we could then further discuss things based on real code proposals?</p>
<h4 id="rmetrich_commented_at_2021-04-19_1215"><img src="https://avatars.githubusercontent.com/u/1163635?u=36b5e32e1dd55f1ce77cad431a5683fce40a7934&v=4" width="50"><a href="https://github.com/rmetrich">rmetrich</a> commented at <a href="https://github.com/rear/rear/pull/2597#issuecomment-822420675">2021-04-19 12:15</a>:<a class="headerlink" href="#rmetrich_commented_at_2021-04-19_1215" title="Permanent link">&para;</a></h4>
<p>Hi @jsmeix no worry, my hack is just a proposal, if you believe we can
do better, I'll be happy to reject this :)<br />
Unfortunately I'm busy with other stuff and cannot contribute to rear
yet.</p>
<h4 id="jsmeix_commented_at_2021-04-19_1235"><img src="https://avatars.githubusercontent.com/u/1788608?u=925fc54e2ce01551392622446ece427f51e2f0ce&v=4" width="50"><a href="https://github.com/jsmeix">jsmeix</a> commented at <a href="https://github.com/rear/rear/pull/2597#issuecomment-822431778">2021-04-19 12:35</a>:<a class="headerlink" href="#jsmeix_commented_at_2021-04-19_1235" title="Permanent link">&para;</a></h4>
<p>Just an offhanded thought FYI:</p>
<p><a href="https://github.com/rear/rear/issues/1271#issuecomment-822425412">https://github.com/rear/rear/issues/1271#issuecomment-822425412</a><br />
may indicate we may also need something like<br />
an <code>EXCLUDE_DISKS</code> config variable (that is empty by default)<br />
so that the user could (if needed) specify his sacrosanct disks.</p>
<p>Perhaps ideally not only as kernel device nodes (with or without path)
like</p>
<pre><code>EXCLUDE_DISKS=( /dev/sdc sdc )
</code></pre>
<p>but also via any device node symlink (with or without path) like</p>
<pre><code>EXCLUDE_DISKS=( /dev/disk/by-label/REAR-000 REAR-000 )
</code></pre>
<h4 id="pcahyna_commented_at_2021-04-19_1254"><img src="https://avatars.githubusercontent.com/u/26300485?u=9105d243bc9f7ade463a3e52e8dd13fa67837158&v=4" width="50"><a href="https://github.com/pcahyna">pcahyna</a> commented at <a href="https://github.com/rear/rear/pull/2597#issuecomment-822443256">2021-04-19 12:54</a>:<a class="headerlink" href="#pcahyna_commented_at_2021-04-19_1254" title="Permanent link">&para;</a></h4>
<p>@jsmeix</p>
<blockquote>
<p>regarding your <a href="https://github.com/rear/rear/pull/2597#issuecomment-816671377">#2597
(comment)</a></p>
<p>The commonly used point of view is that in the tree-like structure of
storage objects<br />
(it is no tree because one higher level storage object could have more
than one parent<br />
e.g. a non-degraded software RAID array "md" device has at least two
parent devices)<br />
the actual disks are the root devices and on them certain levels of
higher and higher<br />
level storage objects are built until the leaves are usually some
"mountable thingies"<br />
(like filesystems or btrfs subvolumes).</p>
</blockquote>
<p>Yes, when I wrote that comment I had an opposite view in mind: the
"mountable thingies" as roots and the actual disks as leaves. Of course
since the tree is not actually a tree but a DAG, both viewpoints (with
actual disks as roots vs. with mountable thingies as roots) can be
considered equally valid (or invalid), but my comment should be
interpreted with the "mountable thingies as roots" view in mind.</p>
<blockquote>
<p>This commonly used point of view is what <code>lsblk</code> shows<br />
and what admins usually have in mind when they imagine<br />
their particular tree-like structure of storage objects on their
machines.</p>
</blockquote>
<p>I had in mind the output of <code>lsblk --inverse</code></p>
<blockquote>
<p>Cf. what Stefan Hundhammer wrote in<br />
<a href="https://lists.opensuse.org/archives/list/yast-devel@lists.opensuse.org/thread/YK6MJ4WYT5TS672FMOKK2BNULCNLFIE6/">https://lists.opensuse.org/archives/list/yast-devel@lists.opensuse.org/thread/YK6MJ4WYT5TS672FMOKK2BNULCNLFIE6/</a><br />
(excerpt):</p>
<pre><code>Users know they have disks in their computers; so we should represent 
them, visualize them. This is the primary handle for users because it 
corresponds to something from the real world; something they can touch, 
something they can buy in a shop. You can't buy a partition or an LVM, 
but you CAN buy a disk. Don't take away from users the few things from 
the real world that they can make sense of in this context. ;-)
</code></pre>
<p>Same appies for virtual disks.<br />
Virtual disks are what admins have first and foremost on virtual
machines.</p>
<p>So in ReaR we also should let the user specify his things<br />
according to how he is used to imagine his things,<br />
i.e. first and foremost disks.</p>
<p>So far from a usability point of view.</p>
</blockquote>
<p>I am not sure that I agree with this view. Users buy disks to put the
"mountable thingies" and eventually data on them, so they may buy a
disk, but ultimately they are interested in the data, not disks.<br />
The discussion you reference, is AFAICT, about the installer, which can
have different usability requirements than a backup/recovery tool. (When
you install a system, you don't have any data on it yet.) If anything,
the discussion is more relevant to the recover phase, not to the backup
phase (indeed, in the recover phase, you certainly want to have a
detailed control over what disks are going to be used, since you don't
want to overwrite disks that still have valuable data. Similar concerns
apply when installing, so here the installer is a more relevant analogy
to the recover phase than to the backup/mkrestore part.)</p>
<blockquote>
<p>Now from a "what ReaR is meant to do" point of view:</p>
<p>ReaR's main task is to recreate a system as much as possible as it was
before<br />
on bare metal replacement hardware (or on bare virtual machines).</p>
<p>It is not ReaR's main task to initially create a system where it might
make sense<br />
to let the user specify the final storage objects (usually "mountable
thingies")<br />
and let some (semi)-automatism create the needed lower and lower
level<br />
storage objects until finally some disks are used (those where the
intended<br />
final storage objects fit best).</p>
<p>It is ReaR's main task is to use "same" disks as on the original
system<br />
and recreate on them the same structure of higher and higher<br />
level storage objects.</p>
</blockquote>
<p>It seems that what you say goes a bit against the current philosophy of
ReaR though, because the current include/exclude rules are often
formulated in terms of the final (or close to final) storage objects:
<code>ONLY_INCLUDE_VG</code>, <code>EXCLUDE_MOUNTPOINTS</code>, <code>EXCLUDE_VG</code>,
<code>EXCLUDE_RECREATE</code> - even <code>AUTOEXCLUDE_DISKS</code> excludes disk that are not
used by mounted filesystems.</p>
<p>(I admit I am not familiar enough with the current include/exclude
rules.)</p>
<p>Thinking in terms of "mountable thingies" has also the advantage of
naturally mapping to backups, because usually those are the only objects
that one knows how to backup (unless one uses a method like BLOCKCLONE,
but I suppose it is not very typical).</p>
<blockquote>
<p>Finally from a technical point of view:</p>
<p>To create a structure of storage objects on bare metal replacement
hardware<br />
(or on a bare virtual machine) one must start with disks, create
partitions on them,<br />
and so on.</p>
<p>Therefore ReaR uses "whole" disks when recreating<br />
and its first thing is <code>parted mklabel</code>, then <code>parted mkpart</code> and so
on.</p>
<p>There is no code in ReaR to "partially" recreate storage objects on a
disk.</p>
</blockquote>
<p>Well, I suspect that if you exclude a VG that has a PV on a partition of
a disk, it is allowed to recreate the partition without recreating the
PV and VG that resides in it. The disk will then indeed become
"partially recreated". (I haven't tried it though.)</p>
<blockquote>
<p>Summary (from my point of view):</p>
<p>It would help the user a lot if he could specify with final power<br />
what disks ReaR has to use (and then all other disks must not be
used).</p>
</blockquote>
<p>If you want to go this route, please let the user specify the disks in
terms of some stable identifier (/dev/disk/by-*) instead of using block
device names.</p>
<blockquote>
<p>When a higher level storage object (e.g. a LV in a VG that is spread
over several disks)<br />
uses a disk that is not specified to be used (if the user has
specified what to use)<br />
ReaR (i.e. "rear mkrescue") must error out so the user would see the
conflict.</p>
</blockquote>
<p>Sure.</p>
<h4 id="jsmeix_commented_at_2021-04-19_1402"><img src="https://avatars.githubusercontent.com/u/1788608?u=925fc54e2ce01551392622446ece427f51e2f0ce&v=4" width="50"><a href="https://github.com/jsmeix">jsmeix</a> commented at <a href="https://github.com/rear/rear/pull/2597#issuecomment-822491263">2021-04-19 14:02</a>:<a class="headerlink" href="#jsmeix_commented_at_2021-04-19_1402" title="Permanent link">&para;</a></h4>
<p>I admit never really understood the current include/exclude rules.</p>
<p>I can "understand" a particular case by trial and error plus reading the
code<br />
but I don't have an overall understanding in my mind to be able to
tell<br />
off the top of my head what config variables must be set with which
values<br />
to get a desided outcome.</p>
<p>From my failed attempts to understand things my result<br />
that I personally think the whole include/exclude area<br />
has become a grown "hairy" mess over the time, cf.<br />
<a href="https://github.com/rear/rear/pull/2597#issuecomment-814895323">https://github.com/rear/rear/pull/2597#issuecomment-814895323</a></p>
<p>My vague basic understanding is that during "rear mkrescue"<br />
first all storage objects ReaR knows about are included in
disklayout.conf<br />
(except some automated hardcoded ignored ones, cf. this issue here)<br />
and then some "not needed" entries in disklayout.conf get disabled<br />
by various subsequent <code>exclude</code> scripts which is the main "hairy" part.</p>
<p>Cf. what <code>rear -s mkrescue | grep layout/save</code> shows (excerpts)</p>
<pre><code>Source layout/save/GNU/Linux/200_partition_layout.sh
...
Source layout/save/GNU/Linux/220_lvm_layout.sh
Source layout/save/GNU/Linux/230_filesystem_layout.sh
...
Source layout/save/default/310_include_exclude.sh
Source layout/save/default/320_autoexclude.sh
Source layout/save/default/330_remove_exclusions.sh
</code></pre>
<p>A bad consequence is that when ReaR does not support something<br />
it gets silently ignored during "rear mkrescue" and then the user has
to<br />
learn the hard way later (when it is too late) when "rear recover"
fails<br />
with unfriedly messages that something is not supported by ReaR, cf.<br />
<a href="https://github.com/rear/rear/issues/2560">https://github.com/rear/rear/issues/2560</a></p>
<p>E.g. as far as I know off the top of my head<br />
a mounted filesystem that is not supported by ReaR is silently ignored
and<br />
an unsupported storage object is also silently ignored during "rear
mkrescue"<br />
for the latter see
<a href="https://github.com/rear/rear/issues/2560">https://github.com/rear/rear/issues/2560</a></p>
<p>What is missing is the final power where the user could specify<br />
what he wants and "rear mkrescue" fails if it cannot fulfill that<br />
and where the uscer could specify what is sacrosanct<br />
for ReaR and "rear mkrescue" fails if it needs that.</p>
<p>Ideally ReaR would have sufficient automated checks<br />
that find out when something unsupported is actually in use<br />
so "rear mkrescue" could error out to have the user informed in time<br />
when he can adapt and enhance things to make "rear recover" work.</p>
<p>Let me experiment a bit with some generic <code>INCLUDE_DISKS</code><br />
and <code>EXCLUDE_DISKS</code> functionality to find out how that works<br />
in practice at least for me then let's see if that way looks promising.</p>
<h4 id="github-actions_commented_at_2021-06-21_0225"><img src="https://avatars.githubusercontent.com/in/15368?v=4" width="50"><a href="https://github.com/apps/github-actions">github-actions</a> commented at <a href="https://github.com/rear/rear/pull/2597#issuecomment-864677473">2021-06-21 02:25</a>:<a class="headerlink" href="#github-actions_commented_at_2021-06-21_0225" title="Permanent link">&para;</a></h4>
<p>Stale pull request message</p>
<h4 id="jsmeix_commented_at_2021-06-23_1057"><img src="https://avatars.githubusercontent.com/u/1788608?u=925fc54e2ce01551392622446ece427f51e2f0ce&v=4" width="50"><a href="https://github.com/jsmeix">jsmeix</a> commented at <a href="https://github.com/rear/rear/pull/2597#issuecomment-866738609">2021-06-23 10:57</a>:<a class="headerlink" href="#jsmeix_commented_at_2021-06-23_1057" title="Permanent link">&para;</a></h4>
<p>This issue is not forgotten - only too much other stuff went in the
way.<br />
Hopefully I find time next week...</p>
<h4 id="gdha_commented_at_2021-07-02_0716"><img src="https://avatars.githubusercontent.com/u/888633?u=cdaeb31efcc0048d3619651aa18dd4b76e636b21&v=4" width="50"><a href="https://github.com/gdha">gdha</a> commented at <a href="https://github.com/rear/rear/pull/2597#issuecomment-872777374">2021-07-02 07:16</a>:<a class="headerlink" href="#gdha_commented_at_2021-07-02_0716" title="Permanent link">&para;</a></h4>
<p>@rmetrich @pcahyna @jsmeix Is there no way to investigate why
<code>multipath</code> is so terrible slow? What @rmetrich is trying to implement
yet another work-around (which is sometimes to only way), but it makes
ReaR more complicated towards the end-user who cannot find its way in
all the hundreds variable settings. The main goal is still Relax not
Stress.</p>
<h4 id="jsmeix_commented_at_2021-07-02_1014"><img src="https://avatars.githubusercontent.com/u/1788608?u=925fc54e2ce01551392622446ece427f51e2f0ce&v=4" width="50"><a href="https://github.com/jsmeix">jsmeix</a> commented at <a href="https://github.com/rear/rear/pull/2597#issuecomment-872886629">2021-07-02 10:14</a>:<a class="headerlink" href="#jsmeix_commented_at_2021-07-02_1014" title="Permanent link">&para;</a></h4>
<p>@gdha<br />
I think you may misunderstand two things here:</p>
<p>(1) This particular issue is a special case:</p>
<p>This particular issue is not about a "normal" system.</p>
<p>This issue is about a system with thousands of disks, see<br />
<a href="https://github.com/rear/rear/pull/2597#issuecomment-814908043">https://github.com/rear/rear/pull/2597#issuecomment-814908043</a></p>
<pre><code>... physical devices
...
2653 "/devices/pci..." devices there.
All scanned.
</code></pre>
<p>and<br />
<a href="https://github.com/rear/rear/pull/2597#issuecomment-814957059">https://github.com/rear/rear/pull/2597#issuecomment-814957059</a></p>
<pre><code>... get an idea how long it takes when 'multipath -l' is run 2653 times.
</code></pre>
<p>So <code>multipath</code> is not terrible slow.<br />
But tousands of times <code>multipath</code> gets terrible slow.</p>
<p>Systems with thousands of disks mean stress in general.</p>
<p>Not only with ReaR but basically all tools that deal with disks<br />
may get terrible slow with thousands of disks up to low level things<br />
like possibly udev event storms and things like that<br />
(kernel developers could tell such stories ;-)</p>
<p>So we are thinking about some additional generic INCLUDE_DISKS<br />
and EXCLUDE_DISKS functionality to make it possible for admins<br />
of systems with thousands of disks to have less stress - at least in
ReaR.</p>
<p>I am totally selfish here:<br />
If a SUSE customer with a system with thousands of disks<br />
files an urgent support case at SUSE then I will get stress.<br />
But I do not like stress - actually I really really hate stress.<br />
So to get rid of such customer-introduced "real-time stress"<br />
(likely amplified by some well-intended advice by managers)<br />
I would implement whatever quick and ditry hack to somehow<br />
make that stuff somehow work for the particular customer<br />
to get that annoyance out of my way as quickly as possible.</p>
<p>(2) More and more config variables don't mean stress:</p>
<p>The crucial point with config variables is that normally the user<br />
should not need to care about their values because normally<br />
config variables have a default setting where things "just work".</p>
<p>Only if things do not "just work" the user would have to care<br />
about that specific case where it does not "just work" for him<br />
with his particular system in his particiular environment.</p>
<p>In such a case the user would have to read default.conf to find out<br />
what the right config variables and values are that he must<br />
specifically set to make his special case work.</p>
<p>When there are config variables for basically all and everything<br />
the user has relatively easy means to make his special case work.</p>
<p>When there is no config variable for a particular kind of thing<br />
the user would have to adapt the ReaR scripts that deal<br />
with that particular kind of thing which is less easy compared to<br />
read default.conf and set some appropriate config variables.</p>
<p>But the worst of all when config variables are missing is<br />
that then very most of the users won't adapt the ReaR scripts.</p>
<p>Instead the users make issues here and then we get their stress<br />
and the users are right doing so because only in theory<br />
"simply change the code - that's just what free software is about"<br />
is right but in practice users don't appreciate such habits.</p>
<p>In particular SUSE customers usually won't adapt ReaR scripts<br />
because they want to use "the software" (i.e. the ReaR scripts)<br />
as is from a rear* RPM package same on all their systems<br />
and specify system-dependant things only in config files<br />
on each system as needed.</p>
<p>So having config variables for basically all and everything<br />
means less stress for all of us compared to not having<br />
config variables for basically all and everything.</p>
<p>Adendum:<br />
It is a separated and different topic<br />
if we should have all config variables in a single default.conf<br />
or if we should split them up into commonly used config variables<br />
and config variables for special cases.</p>
<h4 id="github-actions_commented_at_2021-09-01_0212"><img src="https://avatars.githubusercontent.com/in/15368?v=4" width="50"><a href="https://github.com/apps/github-actions">github-actions</a> commented at <a href="https://github.com/rear/rear/pull/2597#issuecomment-909809497">2021-09-01 02:12</a>:<a class="headerlink" href="#github-actions_commented_at_2021-09-01_0212" title="Permanent link">&para;</a></h4>
<p>Stale pull request message</p>
<h4 id="pcahyna_commented_at_2021-09-15_1819"><img src="https://avatars.githubusercontent.com/u/26300485?u=9105d243bc9f7ade463a3e52e8dd13fa67837158&v=4" width="50"><a href="https://github.com/pcahyna">pcahyna</a> commented at <a href="https://github.com/rear/rear/pull/2597#issuecomment-920266696">2021-09-15 18:19</a>:<a class="headerlink" href="#pcahyna_commented_at_2021-09-15_1819" title="Permanent link">&para;</a></h4>
<blockquote>
<p>@rmetrich @pcahyna @jsmeix Is there no way to investigate why
<code>multipath</code> is so terrible slow? What @rmetrich is trying to implement
yet another work-around (which is sometimes to only way), but it makes
ReaR more complicated towards the end-user who cannot find its way in
all the hundreds variable settings. The main goal is still Relax not
Stress.</p>
</blockquote>
<p>@gdha I fully agree with your view in general, and indeed I spent some
time researching why is <code>multipath</code> slow. It turns out, however, that in
the original issue
(<a href="https://bugzilla.redhat.com/show_bug.cgi?id=1946911">https://bugzilla.redhat.com/show_bug.cgi?id=1946911</a>)
the culprit was not multipath devices, but just lots of unmounted SAN
devices, so optimizing multipath would not have helped here.</p>
<p>OTOH, it also turns out that there is indeed a multipath performance
problem that was fixed in PR #2034 but reintroduced in ReaR 2.6. As
written by @jsmeix above:</p>
<blockquote>
<p>@pcahyna<br />
perhaps in the function <code>is_multipath_path</code> in
lib/layout-functions.sh<br />
the most time consuming part is not the device specific call</p>
<pre><code>multipath -c /dev/$1
</code></pre>
<p>but the listing of the whole multipath topology via</p>
<pre><code>multipath -l | grep -q '[[:alnum:]]' || return 1
</code></pre>
<p>see my comment in the code why I added that call<br />
<a href="https://github.com/rear/rear/blob/master/usr/share/rear/lib/layout-functions.sh#L718">https://github.com/rear/rear/blob/master/usr/share/rear/lib/layout-functions.sh#L718</a></p>
</blockquote>
<p>The problematic change is here:
<a href="https://github.com/rear/rear/pull/2299/files#diff-2916f533f1aa01a8a571a7062e43957bdd1523e70ce94a5107541ff466eef22cR705">https://github.com/rear/rear/pull/2299/files#diff-2916f533f1aa01a8a571a7062e43957bdd1523e70ce94a5107541ff466eef22cR705</a>
- for each device, it issues <code>multipath -l</code>. And since <code>multipath -l</code>
scans all devices and the time it takes is proportional to their number,
the total time spent on all this is quadratic in the number of devices.
For 1600 devices it used to take 300 s, now it takes 4445 s. I will try
to propose a fix for that (using the strategy mentioned in
<a href="https://github.com/rear/rear/pull/2597#issuecomment-815038677">https://github.com/rear/rear/pull/2597#issuecomment-815038677</a>
or
<a href="https://github.com/rear/rear/pull/2597#issuecomment-816587171">https://github.com/rear/rear/pull/2597#issuecomment-816587171</a>
).</p>
<h4 id="jsmeix_commented_at_2021-11-11_1150"><img src="https://avatars.githubusercontent.com/u/1788608?u=925fc54e2ce01551392622446ece427f51e2f0ce&v=4" width="50"><a href="https://github.com/jsmeix">jsmeix</a> commented at <a href="https://github.com/rear/rear/pull/2597#issuecomment-966239603">2021-11-11 11:50</a>:<a class="headerlink" href="#jsmeix_commented_at_2021-11-11_1150" title="Permanent link">&para;</a></h4>
<p>@pcahyna @rmetrich @rear/contributors<br />
please have a look at
<a href="https://github.com/rear/rear/pull/2708">https://github.com/rear/rear/pull/2708</a></p>
<h4 id="jsmeix_commented_at_2021-11-15_1231"><img src="https://avatars.githubusercontent.com/u/1788608?u=925fc54e2ce01551392622446ece427f51e2f0ce&v=4" width="50"><a href="https://github.com/jsmeix">jsmeix</a> commented at <a href="https://github.com/rear/rear/pull/2597#issuecomment-968865301">2021-11-15 12:31</a>:<a class="headerlink" href="#jsmeix_commented_at_2021-11-15_1231" title="Permanent link">&para;</a></h4>
<p>With
<a href="https://github.com/rear/rear/pull/2708">https://github.com/rear/rear/pull/2708</a>
merged<br />
at least the long computing time in
layout/save/GNU/Linux/200_partition_layout.sh<br />
should be avoided.</p>
<p>I don't know if the "Grub2 probe running for 20 minutes" issue<br />
in output/default/940_grub2_rescue.sh can be avoided, see<br />
<a href="https://github.com/rear/rear/pull/2597#issuecomment-814950019">https://github.com/rear/rear/pull/2597#issuecomment-814950019</a><br />
When it hangs inside a command call (e.g. when GRUB is slow)<br />
there is perhaps not much what ReaR could do.<br />
At least that code is only run when GRUB_RESCUE is wanted by the user.</p>
<h4 id="github-actions_commented_at_2022-01-15_0223"><img src="https://avatars.githubusercontent.com/in/15368?v=4" width="50"><a href="https://github.com/apps/github-actions">github-actions</a> commented at <a href="https://github.com/rear/rear/pull/2597#issuecomment-1013588354">2022-01-15 02:23</a>:<a class="headerlink" href="#github-actions_commented_at_2022-01-15_0223" title="Permanent link">&para;</a></h4>
<p>Stale pull request message</p>
<hr />
<p>[Export of Github issue for
<a href="https://github.com/rear/rear">rear/rear</a>.]</p>
              
            </div>
          </div>

<footer>
  

  <hr/>

  <div role="contentinfo">
    <!-- Copyright etc -->
    
    <p>Copyright 2025 - CC0 1.0 Universal<br />Give <a href="https://github.com/rear/rear-user-guide/issues/new?title=issues/2021-04-07.2597.pr.closed.html">feedback</a> on this page.</p>
    
  </div>
</footer>

        </div>
      </div>

    </section>

  </div>

  <div class="rst-versions" role="note" aria-label="Versions">
  <span class="rst-current-version" data-toggle="rst-current-version">
    
        <span>
          <a href="https://github.com/rear/rear-user-guide" class="fa fa-code-fork" style="color: #fcfcfc"> rear/rear-user-guide</a>
        </span>
    
    
    
  </span>
</div>
    <script src="../js/jquery-3.6.0.min.js"></script>
    <script>var base_url = "..";</script>
    <script src="../js/theme_extra.js"></script>
    <script src="../js/theme.js"></script>
      <script src="../search/main.js"></script>
    <script>
        jQuery(function () {
            SphinxRtdTheme.Navigation.enable(true);
        });
    </script>

</body>
</html>
