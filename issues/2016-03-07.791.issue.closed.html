<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
    
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
      <link rel="shortcut icon" href="../img/favicon.ico" />
    <meta property="og:title" content="Relax-and-Recover (ReaR) User Guide Documentation"/>
    <meta property="og:description" content="This is an umbrella documentation project for all Relax-and-Recover (ReaR) kind of documentation ans starting with a good User Guide."/>
    <meta property="og:locale" content="en_US"/>
    <meta property="og:url" content="https://relax-and-recover.org/rear-user-guide/"/>
    <meta property="og:type" content="website"/>
    <meta property="og:image" content="https://relax-and-recover.org/rear-user-guide/img/rear_logo_50.png"/>
    <meta property="og:image:width" content="50"/>
    <meta property="og:image:height" content="50"/>
    
    <title>#791 Issue closed: Waiting for udev and "kicking udev" are wrong (both miss the point) - Relax-and-Recover (ReaR) User Guide Documentation</title>
    <link rel="stylesheet" href="../css/theme.css" />
    <link rel="stylesheet" href="../css/theme_extra.css" />
        <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/styles/github.min.css" />
        <link href="../css/rear.css" rel="stylesheet" />
    
      <script>
        // Current page data
        var mkdocs_page_name = "#791 Issue closed: Waiting for udev and \"kicking udev\" are wrong (both miss the point)";
        var mkdocs_page_input_path = "issues/2016-03-07.791.issue.closed.md";
        var mkdocs_page_url = null;
      </script>
    
    <!--[if lt IE 9]>
      <script src="../js/html5shiv.min.js"></script>
    <![endif]-->
      <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/highlight.min.js"></script>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/languages/yaml.min.js"></script>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/languages/rust.min.js"></script>
      <script>hljs.highlightAll();</script> 
      <script>
        (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
        (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
        m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
        })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

        ga('create', "366986045", "auto");
        ga('send', 'pageview');
      </script>
    
</head>

<body class="wy-body-for-nav" role="document">

  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side stickynav">
    <div class="wy-side-scroll">
      <div class="wy-side-nav-search">
          <a href="../index.html" class="icon icon-home"> Relax-and-Recover (ReaR) User Guide Documentation
        </a><div role="search">
  <form id ="rtd-search-form" class="wy-form" action="../search.html" method="get">
      <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" title="Type search term here" />
  </form>
</div>
      </div>

      <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <ul>
                <li class="toctree-l1"><a class="reference internal" href="../index.html">Relax-and-Recover (ReaR) User Guide Documentation</a>
                </li>
              </ul>
              <p class="caption"><span class="caption-text">WELCOME</span></p>
              <ul>
                  <li class="toctree-l1"><a class="reference internal" href="../welcome/index.html">Get started!</a>
                  </li>
              </ul>
              <p class="caption"><span class="caption-text">BASICS</span></p>
              <ul>
                  <li class="toctree-l1"><a class="reference internal" href="../basics/introduction.html">Introduction</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../basics/history.html">Bit of History</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../basics/getting-started.html">Getting started with ReaR</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../basics/configuration.html">Basic configuration</a>
                  </li>
              </ul>
              <p class="caption"><span class="caption-text">SCENARIOS</span></p>
              <ul>
                  <li class="toctree-l1"><a class="reference internal" href="../scenarios/index.html">Scenarios Overview</a>
                  </li>
              </ul>
              <p class="caption"><span class="caption-text">DEVELOPMENT</span></p>
              <ul>
                  <li class="toctree-l1"><a class="reference internal" href="../development/github-pr.html">Make a pull request with GitHub</a>
                  </li>
              </ul>
              <p class="caption"><span class="caption-text">RELEASE NOTES</span></p>
              <ul>
                  <li class="toctree-l1"><a class="reference internal" href="../releasenotes/index.html">Release Notes</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../releasenotes/rear27.html">Release Notes ReaR 2.7</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../releasenotes/rear26.html">Release Notes ReaR 2.6</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../releasenotes/knownproblems.html">Known Problems and Workarounds</a>
                  </li>
              </ul>
              <p class="caption"><span class="caption-text">ISSUES</span></p>
              <ul>
                  <li class="toctree-l1"><a class="reference internal" href="index.html">Issues History</a>
                  </li>
              </ul>
              <p class="caption"><span class="caption-text">LEGAL</span></p>
              <ul>
                  <li class="toctree-l1"><a class="reference internal" href="../legal/contributing/index.html">Contributing</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../legal/license/index.html">License</a>
                  </li>
              </ul>
      </div>
    </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">
      <nav class="wy-nav-top" role="navigation" aria-label="Mobile navigation menu">
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">Relax-and-Recover (ReaR) User Guide Documentation</a>
        
      </nav>
      <div class="wy-nav-content">
        <div class="rst-content"><div role="navigation" aria-label="breadcrumbs navigation">
  <ul class="wy-breadcrumbs">
    <li><a href="../index.html" class="icon icon-home" aria-label="Docs"></a></li>
      <li class="breadcrumb-item active">#791 Issue closed: Waiting for udev and "kicking udev" are wrong (both miss the point)</li>
    <li class="wy-breadcrumbs-aside">
    </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
            <div class="section" itemprop="articleBody">
              
                <h1 id="791_issue_closed_waiting_for_udev_and_kicking_udev_are_wrong_both_miss_the_point"><a href="https://github.com/rear/rear/issues/791">#791 Issue</a> <code>closed</code>: Waiting for udev and "kicking udev" are wrong (both miss the point)<a class="headerlink" href="#791_issue_closed_waiting_for_udev_and_kicking_udev_are_wrong_both_miss_the_point" title="Permanent link">&para;</a></h1>
<p><strong>Labels</strong>: <code>enhancement</code>, <code>cleanup</code>, <code>severe improvement</code></p>
<h4 id="jsmeix_opened_issue_at_2016-03-07_0928"><img src="https://avatars.githubusercontent.com/u/1788608?u=925fc54e2ce01551392622446ece427f51e2f0ce&v=4" width="50"><a href="https://github.com/jsmeix">jsmeix</a> opened issue at <a href="https://github.com/rear/rear/issues/791">2016-03-07 09:28</a>:<a class="headerlink" href="#jsmeix_opened_issue_at_2016-03-07_0928" title="Permanent link">&para;</a></h4>
<p>Waiting for udev and "kicking udev" are wrong (both miss the point).</p>
<p>Currently rear waits for udev either via something like</p>
<pre>
udevadm settle
</pre>

<p>or by simple sleeping for a while.</p>
<p>Both miss the point and therefore both will never work reliably so that
in the end both is wrong.</p>
<p>That sleeping for a while cannot work reliably is clear.</p>
<p>Below I explain why even testing if all current udev events are handled
via "udevadm settle" cannot work reliably in any case (hint: the crucial
word is "current").</p>
<p>The right way is to wait for the actual "thingy" that is needed by the
subsequent commands.</p>
<p>Example:</p>
<p>Wrong:</p>
<pre>
# Wait for udev to have the harddisk available:
udevadm settle
# Create partitions on the harddisk:
parted ... /dev/sda
# Wait for udev to have the harddisk partitions available:
udevadm settle
# Make filesystem on harddisk partition:
mkfs ... /dev/sda1
</pre>

<p>Right:</p>
<pre>
# Wait until harddisk device node is available:
for countdown in $( seq 60 -1 0 ) ; do
    test -b /dev/sda && break
    LogPrint "Waiting for /dev/sda ($countdown)"
    sleep 1
done
test -b /dev/sda || Error "No /dev/sda available"
# Create partitions on the harddisk:
parted ... /dev/sda
# Wait until harddisk partition device node is available:
for countdown in $( seq 60 -1 0 ) ; do
    test -b /dev/sda1 && break
    LogPrint "Waiting for /dev/sda1 ($countdown)"
    sleep 1
done
test -b /dev/sda1 || Error "No /dev/sda1 available"
# Make filesystem on harddisk partition:
mkfs ... /dev/sda1
</pre>

<p>Reason:</p>
<p>udev is event driven.</p>
<p>This means udev events happen at arbitrary time.</p>
<p>For example the hardware plus the kernel may lead to "delayed" or "very
late" udev events.</p>
<p>Therefore code like</p>
<pre>
parted ... /dev/sda
udevadm settle
mkfs ... /dev/sda1
</pre>

<p>cannot work reliably because at the time when "udevadm settle" is called
there might not yet be any udev event so that "udevadm settle" exits
regardless that there is not yet a /dev/sda1 because its udev event is
for whatever reason "too late".<br />
Actually a udev event is never "too late" but just late (for whatever
reason).<br />
Of course it is unlikely that such a udev event is "too late" but that
only means it is unlikely that such code fails.<br />
But that also means when such code fails for one particular user it is
unlikely that others can reproduce it (and understand what actually is
wrong) which means it becomes unlikely that such issues will be fixed
properly.</p>
<h4 id="jsmeix_commented_at_2016-03-11_1109"><img src="https://avatars.githubusercontent.com/u/1788608?u=925fc54e2ce01551392622446ece427f51e2f0ce&v=4" width="50"><a href="https://github.com/jsmeix">jsmeix</a> commented at <a href="https://github.com/rear/rear/issues/791#issuecomment-195323149">2016-03-11 11:09</a>:<a class="headerlink" href="#jsmeix_commented_at_2016-03-11_1109" title="Permanent link">&para;</a></h4>
<p>Also "kicking udev" is wrong (at least usually), see
<a href="https://github.com/rear/rear/issues/793#issuecomment-194753486">https://github.com/rear/rear/issues/793#issuecomment-194753486</a>
(excerpts):</p>
<p>As far as I was told "kicking udev" does not make sense.</p>
<p>Reason:</p>
<p>Again the crucial point is that the whole suff works based on events.</p>
<p>When "nothing happens" in udev it means there are no events.</p>
<p>When there are no events it does not change anything to "kick udev"
because udev will do nothing when there are no events.</p>
<p>Again the right way is the same idea as above which is in this case:</p>
<p>"Kick" the actual "thingy" that generates events for udev.</p>
<p>The actual "thingy" that generates events for udev is the kernel.</p>
<p>For example:</p>
<p>When a partitioning tool has written whatever data on a harddisk<br />
that is meant to be used by the kernel as partitioning information,<br />
then the kernel does not "magically" know that those blocks<br />
which were written right now are partitioning data.<br />
The kernel blindly writes the blocks onto the harddisk.<br />
Afterwards the kernel must be explicitly told to read<br />
the new partitioning information from the harddisk.<br />
Traditionally this was done by explicitly calling "partprobe"<br />
after using a partitioning tool but I was told that nowadays<br />
partitioning tools have been enhanced that when finishing<br />
they automatically tell the kernel to read the new partitioning<br />
information from the harddisk.</p>
<p>FYI regarding the "I was told" above:<br />
I am not at all a kernel or udev or partitioning tools expert.<br />
I only report here what "I was told".</p>
<h4 id="thefrenchone_commented_at_2016-03-11_1755"><img src="https://avatars.githubusercontent.com/u/17705716?v=4" width="50"><a href="https://github.com/thefrenchone">thefrenchone</a> commented at <a href="https://github.com/rear/rear/issues/791#issuecomment-195478237">2016-03-11 17:55</a>:<a class="headerlink" href="#thefrenchone_commented_at_2016-03-11_1755" title="Permanent link">&para;</a></h4>
<p>Just a note that I do observe the current code using my_udevsettle
being an issue on RHEL 7. It's rare when this process fails but in a few
circumstance parted will fail with the device being busy.</p>
<p>While I was testing my partprobe issue #793 I often had to insert
sleeps in front of the parted commands or clear the disks before
restarting "rear recover".<br />
The issue is reproducible if I was to exit rear where partprobe would
fail and restart "rear recover". In general this was reproducible if I
interrupted rear after disk layout and restarted recovery.</p>
<p>My workaround was to insert sleeps when parted would fail or I would
just forcefully remove the root LVM volume group.</p>
<p>Under normal use, when rear doesn't need to be restarted, parted did not
fail.</p>
<h4 id="jsmeix_commented_at_2016-03-14_0907"><img src="https://avatars.githubusercontent.com/u/1788608?u=925fc54e2ce01551392622446ece427f51e2f0ce&v=4" width="50"><a href="https://github.com/jsmeix">jsmeix</a> commented at <a href="https://github.com/rear/rear/issues/791#issuecomment-196212960">2016-03-14 09:07</a>:<a class="headerlink" href="#jsmeix_commented_at_2016-03-14_0907" title="Permanent link">&para;</a></h4>
<p>Only an idea reagarding "forcefully remove the root LVM volume group
before restarting 'rear recover'", see
<a href="https://github.com/rear/rear/issues/540">https://github.com/rear/rear/issues/540</a>
"Implement a generic 'cleanupdisk' function".</p>
<p>I guess when you have a higher stack of storage objects like filesystem
on top of LVM on top of partitions on top of the harddisk (cf.
<a href="https://github.com/rear/rear/issues/540#issuecomment-71773772">https://github.com/rear/rear/issues/540#issuecomment-71773772</a>)
then it takes more time until kernel/udev/whatever_tools_run_by_udev
all got triggered/launched/finished which could be the reason that in
your case you need to wait at least 3 secounds until partprobe suceeds
while in my test-case (plain filesystem on partition on harddisk)
everything works "fast as lightning".</p>
<p>Furthermore when you have a higher stack of storage objects you may need
to do an appropriately higher stack of actions to wipe the various kind
of metadata information blocks from the harddisk that belong to each
layer of storage objects.<br />
If you miss to wipe metadata information from the harddisk that belong
to old/outdated layers of storage objects, then when you re-use that
harddisk this or that tools that belong to each layer of storage objects
get confused when they read old/outdated metadata information from the
harddisk.<br />
As far as I know this or that tools that belong to each layer of storage
objects could get launched automatically by udev.<br />
For example if you re-use a harddisk that had before LVM on it, it may
happen that after creating partitions from scatch on that hsrddisk, udev
may also trigger to run LVM tools (cf.
<a href="https://github.com/rear/rear/issues/540#issuecomment-71814659">https://github.com/rear/rear/issues/540#issuecomment-71814659</a>
and
<a href="https://github.com/rear/rear/issues/533#issuecomment-71441012">https://github.com/rear/rear/issues/533#issuecomment-71441012</a>
that are about MD tools but should describe the general udev behaviour).
When those LVM tools detect remaining old/outdated LVM metadata
information on the harddisk, there could be arbitrarily unexpected
results (e.g. all of a sudden LVM issues may get in your way regardless
that you only had called parted to create partitions).</p>
<p>I you are interested you may also have a look at
<a href="https://github.com/rear/rear/issues/533">https://github.com/rear/rear/issues/533</a>
if you like to get some more information about nowadays mess in the udev
related area where I somehow try to keep rear working nevertheless.</p>
<h4 id="jsmeix_commented_at_2016-03-18_1402"><img src="https://avatars.githubusercontent.com/u/1788608?u=925fc54e2ce01551392622446ece427f51e2f0ce&v=4" width="50"><a href="https://github.com/jsmeix">jsmeix</a> commented at <a href="https://github.com/rear/rear/issues/791#issuecomment-198374112">2016-03-18 14:02</a>:<a class="headerlink" href="#jsmeix_commented_at_2016-03-18_1402" title="Permanent link">&para;</a></h4>
<p>@mattihautameki<br />
I noticed your
<a href="https://github.com/rear/rear/pull/790">https://github.com/rear/rear/pull/790</a>
and I think you could be interested about what I wrote here.</p>
<h4 id="jsmeix_commented_at_2016-04-18_1028"><img src="https://avatars.githubusercontent.com/u/1788608?u=925fc54e2ce01551392622446ece427f51e2f0ce&v=4" width="50"><a href="https://github.com/jsmeix">jsmeix</a> commented at <a href="https://github.com/rear/rear/issues/791#issuecomment-211318620">2016-04-18 10:28</a>:<a class="headerlink" href="#jsmeix_commented_at_2016-04-18_1028" title="Permanent link">&para;</a></h4>
<p>Some interesting information what I found in<br />
an openSUSE bug about parted behaviour:</p>
<p>In
<a href="https://bugzilla.opensuse.org/show_bug.cgi?id=967375">https://bugzilla.opensuse.org/show_bug.cgi?id=967375</a><br />
there is (excerpt):</p>
<pre>
yast fails to find existing partitions
YaST is right, the entry for /dev/sda14
is missing in /proc/partitions.
Likely this is due to the fact that
calling parted for printing the partition table
triggers a udev rescan of the complete disk
and this can cause partitions to disappear
and reappear in /proc/partitions
(and /sys/block/...)
Maybe scattering more calls to "udevadm settle"
can solve the problem but changing parted to
not trigger a udev rescan looks like a better way,
esp. since the rescan with many disks is also slow.
... needles udev storm triggered by RO operation ...
</pre>

<p>That openSUSE bug links to<br />
<a href="http://parted-devel.alioth.debian.narkive.com/BoSuz2Nz/patch-libparted-use-read-only-when-probing-devices-on-linux-1245144">http://parted-devel.alioth.debian.narkive.com/BoSuz2Nz/patch-libparted-use-read-only-when-probing-devices-on-linux-1245144</a><br />
which contains (excerpt):</p>
<pre>
libparted:
Use read only when probing devices on linux
When a device is opened for RW
closing it can trigger other actions,
like udev scanning it for partition changes.
Resolves: rhbz#1245144
</pre>

<p>When (older) parted may cause a "udev storm"<br />
that may lead to partitions to disappear and reappear<br />
it makes it questionable if it is really correct<br />
to only wait for the actual "thingy" because<br />
it may happen that the test for the actual "thingy"<br />
is succesful but a bit later when that "thingy" is<br />
actually needed by the subsequent command<br />
it has disappeared (for a short while).</p>
<p>Perhaps what is needed to make it really work reilably is</p>
<ul>
<li>"udevadm settle" plus</li>
<li>waiting for the actual "thingy" plus</li>
<li>retries of commands that need the actual "thingy"</li>
</ul>
<p>Regarding "retries" see
<a href="https://github.com/rear/rear/issues/793">https://github.com/rear/rear/issues/793</a>
(excerpt):</p>
<pre>
partprobe fails
The only reliable workaround I've found is to
just call partprobe multiple times
</pre>

<h4 id="jsmeix_commented_at_2016-05-23_0854"><img src="https://avatars.githubusercontent.com/u/1788608?u=925fc54e2ce01551392622446ece427f51e2f0ce&v=4" width="50"><a href="https://github.com/jsmeix">jsmeix</a> commented at <a href="https://github.com/rear/rear/issues/791#issuecomment-220923467">2016-05-23 08:54</a>:<a class="headerlink" href="#jsmeix_commented_at_2016-05-23_0854" title="Permanent link">&para;</a></h4>
<p>Right now I noticed another issue that is of interest here:<br />
<a href="https://github.com/cockpit-project/cockpit/issues/3177">https://github.com/cockpit-project/cockpit/issues/3177</a><br />
and<br />
<a href="https://bugzilla.redhat.com/show_bug.cgi?id=1283112">https://bugzilla.redhat.com/show_bug.cgi?id=1283112</a></p>
<p>In general one my Google for something like</p>
<pre>
udevd vs. parted
</pre>

<p>That even more indicates that it is in parctice almost<br />
impossible to implement a generically reliably working way<br />
how to wait for the actual "thingy" that is needed<br />
by the subsequent commands<br />
cf. my last comment
<a href="https://github.com/rear/rear/issues/791#issuecomment-211318620">https://github.com/rear/rear/issues/791#issuecomment-211318620</a></p>
<p>That it is "Fixed in parted-3.1-23.el7" does not help rear<br />
because rear must also work with older parted.<br />
FYI: In SLE11 there is parted-2.3,<br />
in SLE12 and openSUSE Leap 42.1 there is parted-3.1<br />
but I don't know if that fix is also included in the<br />
SLE12/Leap42.1 parted.</p>
<p>Because the more I learn about it<br />
the more I get confused how to make it working<br />
I postpone this issue to any later unspecified<br />
"future rear version".</p>
<h4 id="jsmeix_commented_at_2016-06-03_1410"><img src="https://avatars.githubusercontent.com/u/1788608?u=925fc54e2ce01551392622446ece427f51e2f0ce&v=4" width="50"><a href="https://github.com/jsmeix">jsmeix</a> commented at <a href="https://github.com/rear/rear/issues/791#issuecomment-223589036">2016-06-03 14:10</a>:<a class="headerlink" href="#jsmeix_commented_at_2016-06-03_1410" title="Permanent link">&para;</a></h4>
<p>I found out and got more information:</p>
<p>On my SLES11 system "man udev" reads:</p>
<pre>
udev provides a dynamic device directory containing
only the files for actually present devices. It creates
or removes device node files in the /dev directory
</pre>

<p>In contrast on my openSUSE Leap 42.1 system<br />
(which is basically the same as a SLES12 system)<br />
"man udev" reads:</p>
<pre>
udev supplies the system software with device events,
manages permissions of device nodes and may create additional
symlinks in the /dev directory, or renames network interfaces.
The kernel usually just assigns unpredictable device names
based on the order of discovery.
</pre>

<p>Accordingly udev changed from creating<br />
device node files in the /dev directory under SLE11<br />
to nowadays where it seems the kernel itself creates<br />
device node files in the /dev directory.</p>
<p>I asked one of the SUSE systemd/udev maintainers<br />
and he confirmed it:</p>
<pre><code>Since SLE12, devtmpfs pseudo filesystem is used.
Therefore the kernel creates the device nodes and
udev is simply running the rules to set,
amongst others, device permissions.
</code></pre>
<p>I told him that one same code in "rear" must work<br />
both for SLES11 and for nowadays systems and<br />
I asked him how to enhance plain code like</p>
<pre>
parted ... /dev/sda
mkfs ... /dev/sda1
</pre>

<p>so that it will always (i.e. on SLES11 and SLES12)<br />
work reliably - in particular how to wait for /dev/sda<br />
and /dev/sda1 in the right way so that it always works<br />
and he replied:</p>
<pre><code>The same code for SLE11 and SLE12 will be different.
SLE11 will require more code to wait for udev creating
the block device.
OTOH, I don't think you need extra code to make
this reliable.
As soon as parted will do an ioctl(BLKRRPART)
to the block device, the kernel will re-read the
partition table and recreate the block device node
atomically, so I _think_ this part is synchronous.
But since it's handled by the kernel I'm not sure.
You should ask to the kernel folks to be 100% sure.
</code></pre>
<p>Hmm...<br />
"one same code in rear that works both for SLES11<br />
and for nowadays systems"<br />
versus<br />
"The same code for SLE11 and SLE12 will be different."<br />
proves that this issue cannot be solved.</p>
<p>I just give up here.</p>
<h4 id="jsmeix_commented_at_2016-06-06_1010"><img src="https://avatars.githubusercontent.com/u/1788608?u=925fc54e2ce01551392622446ece427f51e2f0ce&v=4" width="50"><a href="https://github.com/jsmeix">jsmeix</a> commented at <a href="https://github.com/rear/rear/issues/791#issuecomment-223918906">2016-06-06 10:10</a>:<a class="headerlink" href="#jsmeix_commented_at_2016-06-06_1010" title="Permanent link">&para;</a></h4>
<p>I reopen it so that others can notice it.</p>
<p>I added the labels "documentation" and "discuss"<br />
so that others could contribute here.</p>
<p>Perhaps there is a reasonable way how to wait<br />
for device nodes like /dev/sda and /dev/sda1<br />
so that it works both on older systems where udev<br />
creates the device nodes and on newer systems<br />
where the kernel creates the device nodes.</p>
<p>Perhaps my
<a href="https://github.com/rear/rear/issues/791#issuecomment-211318620">https://github.com/rear/rear/issues/791#issuecomment-211318620</a>
might point into the right direction:</p>
<pre>
"udevadm settle" plus
waiting for the actual "thingy" plus
retries of commands that need the actual "thingy"
</pre>

<p>Keep it simple and stupid and just do all together<br />
to make it work on older and newer systems?</p>
<p>I also added "looking for sponsorship" as a request<br />
that others may contribute code (i.e. pull requests)<br />
that implement waiting for device nodes correctly.</p>
<h4 id="jsmeix_commented_at_2016-06-07_0942"><img src="https://avatars.githubusercontent.com/u/1788608?u=925fc54e2ce01551392622446ece427f51e2f0ce&v=4" width="50"><a href="https://github.com/jsmeix">jsmeix</a> commented at <a href="https://github.com/rear/rear/issues/791#issuecomment-224231100">2016-06-07 09:42</a>:<a class="headerlink" href="#jsmeix_commented_at_2016-06-07_0942" title="Permanent link">&para;</a></h4>
<p>And now some more scaring news:</p>
<p>On special hardware (e.g. like IBM z Systems - formerly<br />
System/390 or S/390) there could be thousands of devices<br />
so that a "udevadm settle" for each of them results delays<br />
that sum up to several minutes.</p>
<p>Therefore any kind of generic "wait_for_device()" function<br />
would need some parameter variables in default.conf<br />
so that the admin can specify the exact waiting behaviour<br />
for his particular use-case.</p>
<h4 id="gdha_commented_at_2018-07-19_1625"><img src="https://avatars.githubusercontent.com/u/888633?u=cdaeb31efcc0048d3619651aa18dd4b76e636b21&v=4" width="50"><a href="https://github.com/gdha">gdha</a> commented at <a href="https://github.com/rear/rear/issues/791#issuecomment-406336094">2018-07-19 16:25</a>:<a class="headerlink" href="#gdha_commented_at_2018-07-19_1625" title="Permanent link">&para;</a></h4>
<p>Perhaps it is better to remove all <strong>udev</strong> calls and if discovery of
devices fail we can blame other tools like parted, partprobe, whatever
;-) ?? Or, we keep it like it is?</p>
<h4 id="jsmeix_commented_at_2018-07-20_0730"><img src="https://avatars.githubusercontent.com/u/1788608?u=925fc54e2ce01551392622446ece427f51e2f0ce&v=4" width="50"><a href="https://github.com/jsmeix">jsmeix</a> commented at <a href="https://github.com/rear/rear/issues/791#issuecomment-406513969">2018-07-20 07:30</a>:<a class="headerlink" href="#jsmeix_commented_at_2018-07-20_0730" title="Permanent link">&para;</a></h4>
<p>@gdha<br />
yes, to some degree it is about to remove the <code>udevadm settle</code> calls<br />
but actually it is not about to remove them without any replacement.</p>
<p>Actually it is about to replace useless <code>udevadm settle</code> calls<br />
by useful <code>wait for the actually needed thing</code> code.</p>
<p>This is one of several fundamental issues that are on my<br />
"vague private todo list" to overhaul our current layout code<br />
at whatever time in the future as time permits because<br />
currently things work mostly o.k. (not always perfect but o.k.)<br />
so that currently there is no hurry (therefore <code>ReaR future</code>).</p>
<p>FYI:</p>
<p>My "vague private todo list" to overhaul our current layout code<br />
is about things like<br />
<a href="https://github.com/rear/rear/issues/791">https://github.com/rear/rear/issues/791</a>
(this issue here)<br />
<a href="https://github.com/rear/rear/issues/799">https://github.com/rear/rear/issues/799</a><br />
<a href="https://github.com/rear/rear/issues/987">https://github.com/rear/rear/issues/987</a><br />
<a href="https://github.com/rear/rear/issues/1750">https://github.com/rear/rear/issues/1750</a><br />
<a href="https://github.com/rear/rear/issues/1771">https://github.com/rear/rear/issues/1771</a><br />
and probably some more...</p>
<p>In general in relation to the whole disk layout code<br />
cf.<br />
<a href="https://github.com/rear/rear/issues/1195#issuecomment-368499304">https://github.com/rear/rear/issues/1195#issuecomment-368499304</a><br />
and<br />
<a href="https://github.com/rear/rear/pull/1603#issuecomment-347860869">https://github.com/rear/rear/pull/1603#issuecomment-347860869</a><br />
in particular my currenly latest reasoning<br />
about a "clean design" (of the disk layout code) in<br />
<a href="https://github.com/rear/rear/pull/1091#issuecomment-263819775">https://github.com/rear/rear/pull/1091#issuecomment-263819775</a></p>
<p>Meanwhile I even have a "secret vague idea"<br />
how we could completely overhaul the layout code<br />
without getting in conflict with out current layout code:</p>
<p>My idea is to re-implement it as a new separated stage<br />
for example the new stuff could be called "storage"<br />
in its own <code>usr/share/rear/storage</code> sub-directory<br />
plus a config variable like <code>STORAGE_CODE=storage</code><br />
which defaults to <code>STORAGE_CODE=layout</code> as long<br />
as the new storage code is under development<br />
so that the usr/share/rear/lib/*-workflow.sh scripts<br />
could call the matching stage for example<br />
in lib/recover-workflow.sh something like (excerpt)</p>
<pre>
    case "$STORAGE_CODE" in
        (layout)
            SourceStage "layout/prepare"
            SourceStage "layout/recreate"
            ;;
        (storage)
            SourceStage "storage/recreate/cleanup_disks"
            SourceStage "storage/recreate/create_block_devices"
            SourceStage "storage/recreate/create_filesystems"
            SourceStage "storage/recreate/create_subvolumes"
            SourceStage "storage/recreate/mount_fstree"
            ;;
        (*)
            Error "Unsupported STORAGE_CODE=$STORAGE_CODE"
            ;;
    esac
</pre>

<p>This way we could even safely drop all the old stuff<br />
in the new storage code and keep the layout code<br />
as long as our users need it, cf.<br />
<a href="https://github.com/rear/rear/issues/1390">https://github.com/rear/rear/issues/1390</a></p>
<h4 id="github-actions_commented_at_2020-07-03_0133"><img src="https://avatars.githubusercontent.com/in/15368?v=4" width="50"><a href="https://github.com/apps/github-actions">github-actions</a> commented at <a href="https://github.com/rear/rear/issues/791#issuecomment-653285516">2020-07-03 01:33</a>:<a class="headerlink" href="#github-actions_commented_at_2020-07-03_0133" title="Permanent link">&para;</a></h4>
<p>Stale issue message</p>
<h4 id="gdha_commented_at_2020-07-10_0602"><img src="https://avatars.githubusercontent.com/u/888633?u=cdaeb31efcc0048d3619651aa18dd4b76e636b21&v=4" width="50"><a href="https://github.com/gdha">gdha</a> commented at <a href="https://github.com/rear/rear/issues/791#issuecomment-656500080">2020-07-10 06:02</a>:<a class="headerlink" href="#gdha_commented_at_2020-07-10_0602" title="Permanent link">&para;</a></h4>
<p>@jsmeix Do you still have any plans with this issue? If not, then do
nothing and it will be closed within a few days. Otherwise, we remove
the 'no-issue-activity' label to keep it alive.</p>
<h4 id="jsmeix_commented_at_2020-07-10_1151"><img src="https://avatars.githubusercontent.com/u/1788608?u=925fc54e2ce01551392622446ece427f51e2f0ce&v=4" width="50"><a href="https://github.com/jsmeix">jsmeix</a> commented at <a href="https://github.com/rear/rear/issues/791#issuecomment-656634625">2020-07-10 11:51</a>:<a class="headerlink" href="#jsmeix_commented_at_2020-07-10_1151" title="Permanent link">&para;</a></h4>
<p>All issues that are labeled as</p>
<pre><code>Dedicated Priority Support
critical/security bug
severe improvement
blocker
</code></pre>
<p>should never be closed automatically, cf.<br />
<a href="https://github.com/rear/rear/blob/master/.github/stale.yml">https://github.com/rear/rear/blob/master/.github/stale.yml</a>
and see in particular<br />
<a href="https://github.com/rear/rear/commit/3cf3f5862185787dba622201d1445fcc00d8e29e">https://github.com/rear/rear/commit/3cf3f5862185787dba622201d1445fcc00d8e29e</a></p>
<p>Issues that are labeled as</p>
<pre><code>critical/security bug
blocker
</code></pre>
<p>should usually not be affected by automated close because we usually
work on them.</p>
<p>But issues that are labeled as</p>
<pre><code>Dedicated Priority Support
</code></pre>
<p>could be affected by automated close in particular when the "Dedicated
Priority Support"<br />
activity happens not within the issue but e.g. via personal
communication with a customer<br />
so the public GitHub issue may show no activity for a longer time.</p>
<p>And most of all issues that are labeled as</p>
<pre><code>severe improvement
</code></pre>
<p>are affected by automated close because "severe improvement" tasks<br />
usually take a lot of time and usually move forward very slowly,<br />
cf.
<a href="https://github.com/rear/rear/issues/799#issuecomment-531247109">https://github.com/rear/rear/issues/799#issuecomment-531247109</a><br />
so that such issues often have no activity for a longer time<br />
but they are severe issues that should never be closed automatically<br />
regardless how long it takes to get them solved.</p>
<h4 id="veetaha_commented_at_2023-04-12_2345"><img src="https://avatars.githubusercontent.com/u/36276403?u=b79664bc7eb1d9cf5bd46241f2e7be0c76dc829a&v=4" width="50"><a href="https://github.com/Veetaha">Veetaha</a> commented at <a href="https://github.com/rear/rear/issues/791#issuecomment-1506106085">2023-04-12 23:45</a>:<a class="headerlink" href="#veetaha_commented_at_2023-04-12_2345" title="Permanent link">&para;</a></h4>
<p>Hey @jsmeix I am seeing your issue in the google search for my problem
and it appears to describe exactly the case that I have where I
partition the disk and immediately mkfs and mount it.</p>
<p>I tried your approach with loop and <code>test -b $partition</code> inside of it.
But... It looks like it doesn't work. I am not sure why, but if you are
using the same approach beware that it is still not reliable. From the
cloud-init logs I can tell that even if <code>lsblk</code> says that the partition
exists, it doesn't mean it's safe to <code>mkfs</code>. Here are the logs from my
own cloud-init script:</p>
<pre><code>Waiting for block device at /dev/nvme1n1p1
Block device is available at /dev/nvme1n1p1
&gt; lsblk
NAME          MAJ:MIN RM   SIZE RO TYPE MOUNTPOINT
nvme0n1       259:0    0    30G  0 disk
├─nvme0n1p1   259:2    0    30G  0 part /
└─nvme0n1p128 259:3    0     1M  0 part
nvme1n1       259:1    0 441.5G  0 disk
└─nvme1n1p1   259:4    0 441.5G  0 part
&gt; mkfs.xfs -f /dev/nvme1n1p1
Error accessing specified device /dev/nvme1n1p1: No such file or directory
</code></pre>
<p>The script is the variation of yours under the spoiler below</p>
<details>
<summary>Details</summary>

    function wait_for_block_device {
        path="$1"

        log "Waiting for block device at $path"

        for countdown in $( seq 600 -1 1 ) ; do
            if [ -b $path ]; then
                log "Block device is available at $path"
                return 0
            fi

            log "Waiting for block device $path ($${countdown}00ms left)"
            sleep 0.1s
        done

        error "Block device is not available at $path"
    }

</details>

<p>That's just insane... but I am still seeking a workaround for the
problem</p>
<p>Maybe just retrying <code>mkfs</code> while it returns <code>No such file or directory</code>
could solve this, but that's a crazy workaround one would need to repeat
each time when such a common thing as partitioning + mkfs + mount would
need to be scripted...</p>
<h4 id="jsmeix_commented_at_2023-04-17_0818"><img src="https://avatars.githubusercontent.com/u/1788608?u=925fc54e2ce01551392622446ece427f51e2f0ce&v=4" width="50"><a href="https://github.com/jsmeix">jsmeix</a> commented at <a href="https://github.com/rear/rear/issues/791#issuecomment-1510909074">2023-04-17 08:18</a>:<a class="headerlink" href="#jsmeix_commented_at_2023-04-17_0818" title="Permanent link">&para;</a></h4>
<p>@Veetaha<br />
see my above<br />
<a href="https://github.com/rear/rear/issues/791#issuecomment-211318620">https://github.com/rear/rear/issues/791#issuecomment-211318620</a><br />
how it could happen that device nodes disappear and reappear<br />
so one must also retry commands that need the actual "thingy".</p>
<p>By the way:<br />
For the (not so) fun of it<br />
you may also have a look at<br />
<a href="https://github.com/rear/rear/issues/2908">https://github.com/rear/rear/issues/2908</a><br />
therein in particular<br />
<a href="https://github.com/rear/rear/issues/2908#issuecomment-1378811748">https://github.com/rear/rear/issues/2908#issuecomment-1378811748</a><br />
so</p>
<pre><code># mount /dev/something /mountpoint
# cp /some/file /mountpoint
# umount /mountpoint
</code></pre>
<p>may no longer work reliably because<br />
umount could fail with "target is busy"</p>
<h4 id="veetaha_commented_at_2023-04-24_0026"><img src="https://avatars.githubusercontent.com/u/36276403?u=b79664bc7eb1d9cf5bd46241f2e7be0c76dc829a&v=4" width="50"><a href="https://github.com/Veetaha">Veetaha</a> commented at <a href="https://github.com/rear/rear/issues/791#issuecomment-1519209062">2023-04-24 00:26</a>:<a class="headerlink" href="#veetaha_commented_at_2023-04-24_0026" title="Permanent link">&para;</a></h4>
<p>@jsmeix Thank you! Your issues are a great mine of information. I wish
these common problems and solutions were described somewhere in
udev/parted and other linux device management commands help messages.</p>
<p>I am now using the approach of retrying the command that needs the
actual "thingy", and it should be the ultimate solution.</p>
<hr />
<p>[Export of Github issue for
<a href="https://github.com/rear/rear">rear/rear</a>.]</p>
              
            </div>
          </div>

<footer>
  

  <hr/>

  <div role="contentinfo">
    <!-- Copyright etc -->
    
    <p>Copyright 2024 - CC0 1.0 Universal<br />Give <a href="https://github.com/rear/rear-user-guide/issues/new?title=issues/2016-03-07.791.issue.closed.html">feedback</a> on this page.</p>
    
  </div>
</footer>

        </div>
      </div>

    </section>

  </div>

  <div class="rst-versions" role="note" aria-label="Versions">
  <span class="rst-current-version" data-toggle="rst-current-version">
    
        <span>
          <a href="https://github.com/rear/rear-user-guide" class="fa fa-code-fork" style="color: #fcfcfc"> rear/rear-user-guide</a>
        </span>
    
    
    
  </span>
</div>
    <script src="../js/jquery-3.6.0.min.js"></script>
    <script>var base_url = "..";</script>
    <script src="../js/theme_extra.js"></script>
    <script src="../js/theme.js"></script>
      <script src="../search/main.js"></script>
    <script>
        jQuery(function () {
            SphinxRtdTheme.Navigation.enable(true);
        });
    </script>

</body>
</html>
